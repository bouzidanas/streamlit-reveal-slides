{"ast":null,"code":"import _slicedToArray from \"/home/anasbouzid/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Data } from '../data';\nimport { Field } from '../schema';\nimport { Column } from '../column';\nimport { Vector } from '../vector';\nimport { DataType } from '../type';\nimport { Chunked } from '../vector/chunked';\nvar isArray = Array.isArray;\n/** @ignore */\nexport var selectArgs = function selectArgs(Ctor, vals) {\n  return _selectArgs(Ctor, vals, [], 0);\n};\n/** @ignore */\nexport var selectColumnArgs = function selectColumnArgs(args) {\n  var _selectFieldArgs2 = _selectFieldArgs(args, [[], []]),\n    _selectFieldArgs3 = _slicedToArray(_selectFieldArgs2, 2),\n    fields = _selectFieldArgs3[0],\n    values = _selectFieldArgs3[1];\n  return values.map(function (x, i) {\n    return x instanceof Column ? Column.new(x.field.clone(fields[i]), x) : x instanceof Vector ? Column.new(fields[i], x) : Column.new(fields[i], []);\n  });\n};\n/** @ignore */\nexport var selectFieldArgs = function selectFieldArgs(args) {\n  return _selectFieldArgs(args, [[], []]);\n};\n/** @ignore */\nexport var selectChunkArgs = function selectChunkArgs(Ctor, vals) {\n  return _selectChunkArgs(Ctor, vals, [], 0);\n};\n/** @ignore */\nexport var selectVectorChildrenArgs = function selectVectorChildrenArgs(Ctor, vals) {\n  return _selectVectorChildrenArgs(Ctor, vals, [], 0);\n};\n/** @ignore */\nexport var selectColumnChildrenArgs = function selectColumnChildrenArgs(Ctor, vals) {\n  return _selectColumnChildrenArgs(Ctor, vals, [], 0);\n};\n/** @ignore */\nfunction _selectArgs(Ctor, vals, res, idx) {\n  var value,\n    j = idx;\n  var i = -1,\n    n = vals.length;\n  while (++i < n) {\n    if (isArray(value = vals[i])) {\n      j = _selectArgs(Ctor, value, res, j).length;\n    } else if (value instanceof Ctor) {\n      res[j++] = value;\n    }\n  }\n  return res;\n}\n/** @ignore */\nfunction _selectChunkArgs(Ctor, vals, res, idx) {\n  var value,\n    j = idx;\n  var i = -1,\n    n = vals.length;\n  while (++i < n) {\n    if (isArray(value = vals[i])) {\n      j = _selectChunkArgs(Ctor, value, res, j).length;\n    } else if (value instanceof Chunked) {\n      j = _selectChunkArgs(Ctor, value.chunks, res, j).length;\n    } else if (value instanceof Ctor) {\n      res[j++] = value;\n    }\n  }\n  return res;\n}\n/** @ignore */\nfunction _selectVectorChildrenArgs(Ctor, vals, res, idx) {\n  var value,\n    j = idx;\n  var i = -1,\n    n = vals.length;\n  while (++i < n) {\n    if (isArray(value = vals[i])) {\n      j = _selectVectorChildrenArgs(Ctor, value, res, j).length;\n    } else if (value instanceof Ctor) {\n      j = _selectArgs(Vector, value.schema.fields.map(function (_, i) {\n        return value.getChildAt(i);\n      }), res, j).length;\n    } else if (value instanceof Vector) {\n      res[j++] = value;\n    }\n  }\n  return res;\n}\n/** @ignore */\nfunction _selectColumnChildrenArgs(Ctor, vals, res, idx) {\n  var value,\n    j = idx;\n  var i = -1,\n    n = vals.length;\n  while (++i < n) {\n    if (isArray(value = vals[i])) {\n      j = _selectColumnChildrenArgs(Ctor, value, res, j).length;\n    } else if (value instanceof Ctor) {\n      j = _selectArgs(Column, value.schema.fields.map(function (f, i) {\n        return Column.new(f, value.getChildAt(i));\n      }), res, j).length;\n    } else if (value instanceof Column) {\n      res[j++] = value;\n    }\n  }\n  return res;\n}\n/** @ignore */\nvar toKeysAndValues = function toKeysAndValues(xs, _ref, i) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    k = _ref2[0],\n    v = _ref2[1];\n  return xs[0][i] = k, xs[1][i] = v, xs;\n};\n/** @ignore */\nfunction _selectFieldArgs(vals, ret) {\n  var keys, n;\n  switch (n = vals.length) {\n    case 0:\n      return ret;\n    case 1:\n      keys = ret[0];\n      if (!vals[0]) {\n        return ret;\n      }\n      if (isArray(vals[0])) {\n        return _selectFieldArgs(vals[0], ret);\n      }\n      if (!(vals[0] instanceof Data || vals[0] instanceof Vector || vals[0] instanceof DataType)) {\n        var _Object$entries$reduc = Object.entries(vals[0]).reduce(toKeysAndValues, ret);\n        var _Object$entries$reduc2 = _slicedToArray(_Object$entries$reduc, 2);\n        keys = _Object$entries$reduc2[0];\n        vals = _Object$entries$reduc2[1];\n      }\n      break;\n    default:\n      !isArray(keys = vals[n - 1]) ? (vals = isArray(vals[0]) ? vals[0] : vals, keys = []) : vals = isArray(vals[0]) ? vals[0] : vals.slice(0, n - 1);\n  }\n  var fieldIndex = -1;\n  var valueIndex = -1;\n  var idx = -1,\n    len = vals.length;\n  var field;\n  var val;\n  var _ret = _slicedToArray(ret, 2),\n    fields = _ret[0],\n    values = _ret[1];\n  while (++idx < len) {\n    val = vals[idx];\n    if (val instanceof Column && (values[++valueIndex] = val)) {\n      fields[++fieldIndex] = val.field.clone(keys[idx], val.type, true);\n    } else {\n      var _keys = keys;\n      var _keys$idx = _keys[idx];\n      field = _keys$idx === void 0 ? idx : _keys$idx;\n      if (val instanceof DataType && (values[++valueIndex] = val)) {\n        fields[++fieldIndex] = Field.new(field, val, true);\n      } else if (val && val.type && (values[++valueIndex] = val)) {\n        val instanceof Data && (values[valueIndex] = val = Vector.new(val));\n        fields[++fieldIndex] = Field.new(field, val.type, true);\n      }\n    }\n  }\n  return ret;\n}","map":{"version":3,"names":["Data","Field","Column","Vector","DataType","Chunked","isArray","Array","selectArgs","Ctor","vals","_selectArgs","selectColumnArgs","args","_selectFieldArgs2","_selectFieldArgs","_selectFieldArgs3","_slicedToArray","fields","values","map","x","i","new","field","clone","selectFieldArgs","selectChunkArgs","_selectChunkArgs","selectVectorChildrenArgs","_selectVectorChildrenArgs","selectColumnChildrenArgs","_selectColumnChildrenArgs","res","idx","value","j","n","length","chunks","schema","_","getChildAt","f","toKeysAndValues","xs","_ref","_ref2","k","v","ret","keys","_Object$entries$reduc","Object","entries","reduce","_Object$entries$reduc2","slice","fieldIndex","valueIndex","len","val","_ret","type","_keys","_keys$idx"],"sources":["util/args.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from '../data';\nimport { Field } from '../schema';\nimport { Column } from '../column';\nimport { Vector } from '../vector';\nimport { DataType } from '../type';\nimport { Chunked } from '../vector/chunked';\n\ntype RecordBatchCtor = typeof import('../recordbatch').RecordBatch;\n\nconst isArray = Array.isArray;\n\n/** @ignore */\nexport const selectArgs = <T>(Ctor: any, vals: any[]) => _selectArgs(Ctor, vals, [], 0) as T[];\n/** @ignore */\nexport const selectColumnArgs = <T extends { [key: string]: DataType }>(args: any[]) => {\n    const [fields, values] = _selectFieldArgs<T>(args, [[], []]);\n    return values.map((x, i) =>\n        x instanceof Column ? Column.new(x.field.clone(fields[i]), x) :\n        x instanceof Vector ? Column.new(fields[i], x) as Column<T[keyof T]> :\n                              Column.new(fields[i], [] as Vector<T[keyof T]>[]));\n};\n\n/** @ignore */\nexport const selectFieldArgs = <T extends { [key: string]: DataType }>(args: any[]) => _selectFieldArgs<T>(args, [[], []]);\n/** @ignore */\nexport const selectChunkArgs = <T>(Ctor: any, vals: any[]) => _selectChunkArgs(Ctor, vals, [], 0) as T[];\n/** @ignore */\nexport const selectVectorChildrenArgs = <T extends Vector>(Ctor: RecordBatchCtor, vals: any[]) => _selectVectorChildrenArgs(Ctor, vals, [], 0) as T[];\n/** @ignore */\nexport const selectColumnChildrenArgs = <T extends Column>(Ctor: RecordBatchCtor, vals: any[]) => _selectColumnChildrenArgs(Ctor, vals, [], 0) as T[];\n\n/** @ignore */\nfunction _selectArgs<T>(Ctor: any, vals: any[], res: T[], idx: number) {\n    let value: any, j = idx;\n    let i = -1, n = vals.length;\n    while (++i < n) {\n        if (isArray(value = vals[i])) {\n            j = _selectArgs(Ctor, value, res, j).length;\n        } else if (value instanceof Ctor) { res[j++] = value; }\n    }\n    return res;\n}\n\n/** @ignore */\nfunction _selectChunkArgs<T>(Ctor: any, vals: any[], res: T[], idx: number) {\n    let value: any, j = idx;\n    let i = -1, n = vals.length;\n    while (++i < n) {\n        if (isArray(value = vals[i])) {\n            j = _selectChunkArgs(Ctor, value, res, j).length;\n        } else if (value instanceof Chunked) {\n            j = _selectChunkArgs(Ctor, value.chunks, res, j).length;\n        } else if (value instanceof Ctor) { res[j++] = value; }\n    }\n    return res;\n}\n\n/** @ignore */\nfunction _selectVectorChildrenArgs<T extends Vector>(Ctor: RecordBatchCtor, vals: any[], res: T[], idx: number) {\n    let value: any, j = idx;\n    let i = -1, n = vals.length;\n    while (++i < n) {\n        if (isArray(value = vals[i])) {\n            j = _selectVectorChildrenArgs(Ctor, value, res, j).length;\n        } else if (value instanceof Ctor) {\n            j = _selectArgs(Vector, value.schema.fields.map((_, i) => value.getChildAt(i)!), res, j).length;\n        } else if (value instanceof Vector) { res[j++] = value as T; }\n    }\n    return res;\n}\n\n/** @ignore */\nfunction _selectColumnChildrenArgs<T extends Column>(Ctor: RecordBatchCtor, vals: any[], res: T[], idx: number) {\n    let value: any, j = idx;\n    let i = -1, n = vals.length;\n    while (++i < n) {\n        if (isArray(value = vals[i])) {\n            j = _selectColumnChildrenArgs(Ctor, value, res, j).length;\n        } else if (value instanceof Ctor) {\n            j = _selectArgs(Column, value.schema.fields.map((f, i) => Column.new(f, value.getChildAt(i)!)), res, j).length;\n        } else if (value instanceof Column) { res[j++] = value as T; }\n    }\n    return res;\n}\n\n/** @ignore */\nconst toKeysAndValues = (xs: [any[], any[]], [k, v]: [any, any], i: number) => (xs[0][i] = k, xs[1][i] = v, xs);\n\n/** @ignore */\nfunction _selectFieldArgs<T extends { [key: string]: DataType }>(vals: any[], ret: [Field<T[keyof T]>[], Vector<T[keyof T]>[]]): [Field<T[keyof T]>[], (T[keyof T] | Vector<T[keyof T]>)[]] {\n    let keys: any[], n: number;\n    switch (n = vals.length) {\n        case 0: return ret;\n        case 1:\n            keys = ret[0];\n            if (!(vals[0])) { return ret; }\n            if (isArray(vals[0])) { return _selectFieldArgs(vals[0], ret); }\n            if (!(vals[0] instanceof Data || vals[0] instanceof Vector || vals[0] instanceof DataType)) {\n                [keys, vals] = Object.entries(vals[0]).reduce(toKeysAndValues, ret);\n            }\n            break;\n        default:\n            !isArray(keys = vals[n - 1])\n                ? (vals = isArray(vals[0]) ? vals[0] : vals, keys = [])\n                : (vals = isArray(vals[0]) ? vals[0] : vals.slice(0, n - 1));\n    }\n\n    let fieldIndex = -1;\n    let valueIndex = -1;\n    let idx = -1, len = vals.length;\n    let field: number | string | Field<T[keyof T]>;\n    let val: Vector<T[keyof T]> | Data<T[keyof T]>;\n    let [fields, values] = ret as [Field<T[keyof T]>[], any[]];\n\n    while (++idx < len) {\n        val = vals[idx];\n        if (val instanceof Column && (values[++valueIndex] = val)) {\n            fields[++fieldIndex] = val.field.clone(keys[idx], val.type, true);\n        } else {\n            ({ [idx]: field = idx } = keys);\n            if (val instanceof DataType && (values[++valueIndex] = val)) {\n                fields[++fieldIndex] = Field.new(field, val as DataType, true) as Field<T[keyof T]>;\n            } else if (val && val.type && (values[++valueIndex] = val)) {\n                val instanceof Data && (values[valueIndex] = val = Vector.new(val) as Vector);\n                fields[++fieldIndex] = Field.new(field, val.type, true) as Field<T[keyof T]>;\n            }\n        }\n    }\n    return ret;\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,IAAI,QAAQ,SAAS;AAC9B,SAASC,KAAK,QAAQ,WAAW;AACjC,SAASC,MAAM,QAAQ,WAAW;AAClC,SAASC,MAAM,QAAQ,WAAW;AAClC,SAASC,QAAQ,QAAQ,SAAS;AAClC,SAASC,OAAO,QAAQ,mBAAmB;AAI3C,IAAMC,OAAO,GAAGC,KAAK,CAACD,OAAO;AAE7B;AACA,OAAO,IAAME,UAAU,GAAG,SAAbA,UAAUA,CAAOC,IAAS,EAAEC,IAAW;EAAA,OAAKC,WAAW,CAACF,IAAI,EAAEC,IAAI,EAAE,EAAE,EAAE,CAAC,CAAQ;AAAA;AAC9F;AACA,OAAO,IAAME,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAA2CC,IAAW,EAAI;EACnF,IAAAC,iBAAA,GAAyBC,gBAAgB,CAAIF,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;IAAAG,iBAAA,GAAAC,cAAA,CAAAH,iBAAA;IAArDI,MAAM,GAAAF,iBAAA;IAAEG,MAAM,GAAAH,iBAAA;EACrB,OAAOG,MAAM,CAACC,GAAG,CAAC,UAACC,CAAC,EAAEC,CAAC;IAAA,OACnBD,CAAC,YAAYnB,MAAM,GAAGA,MAAM,CAACqB,GAAG,CAACF,CAAC,CAACG,KAAK,CAACC,KAAK,CAACP,MAAM,CAACI,CAAC,CAAC,CAAC,EAAED,CAAC,CAAC,GAC7DA,CAAC,YAAYlB,MAAM,GAAGD,MAAM,CAACqB,GAAG,CAACL,MAAM,CAACI,CAAC,CAAC,EAAED,CAAC,CAAuB,GAC9CnB,MAAM,CAACqB,GAAG,CAACL,MAAM,CAACI,CAAC,CAAC,EAAE,EAA0B,CAAC;EAAA,EAAC;AAChF,CAAC;AAED;AACA,OAAO,IAAMI,eAAe,GAAG,SAAlBA,eAAeA,CAA2Cb,IAAW;EAAA,OAAKE,gBAAgB,CAAIF,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AAAA;AAC1H;AACA,OAAO,IAAMc,eAAe,GAAG,SAAlBA,eAAeA,CAAOlB,IAAS,EAAEC,IAAW;EAAA,OAAKkB,gBAAgB,CAACnB,IAAI,EAAEC,IAAI,EAAE,EAAE,EAAE,CAAC,CAAQ;AAAA;AACxG;AACA,OAAO,IAAMmB,wBAAwB,GAAG,SAA3BA,wBAAwBA,CAAsBpB,IAAqB,EAAEC,IAAW;EAAA,OAAKoB,yBAAyB,CAACrB,IAAI,EAAEC,IAAI,EAAE,EAAE,EAAE,CAAC,CAAQ;AAAA;AACrJ;AACA,OAAO,IAAMqB,wBAAwB,GAAG,SAA3BA,wBAAwBA,CAAsBtB,IAAqB,EAAEC,IAAW;EAAA,OAAKsB,yBAAyB,CAACvB,IAAI,EAAEC,IAAI,EAAE,EAAE,EAAE,CAAC,CAAQ;AAAA;AAErJ;AACA,SAASC,WAAWA,CAAIF,IAAS,EAAEC,IAAW,EAAEuB,GAAQ,EAAEC,GAAW;EACjE,IAAIC,KAAU;IAAEC,CAAC,GAAGF,GAAG;EACvB,IAAIZ,CAAC,GAAG,CAAC,CAAC;IAAEe,CAAC,GAAG3B,IAAI,CAAC4B,MAAM;EAC3B,OAAO,EAAEhB,CAAC,GAAGe,CAAC,EAAE;IACZ,IAAI/B,OAAO,CAAC6B,KAAK,GAAGzB,IAAI,CAACY,CAAC,CAAC,CAAC,EAAE;MAC1Bc,CAAC,GAAGzB,WAAW,CAACF,IAAI,EAAE0B,KAAK,EAAEF,GAAG,EAAEG,CAAC,CAAC,CAACE,MAAM;KAC9C,MAAM,IAAIH,KAAK,YAAY1B,IAAI,EAAE;MAAEwB,GAAG,CAACG,CAAC,EAAE,CAAC,GAAGD,KAAK;;;EAExD,OAAOF,GAAG;AACd;AAEA;AACA,SAASL,gBAAgBA,CAAInB,IAAS,EAAEC,IAAW,EAAEuB,GAAQ,EAAEC,GAAW;EACtE,IAAIC,KAAU;IAAEC,CAAC,GAAGF,GAAG;EACvB,IAAIZ,CAAC,GAAG,CAAC,CAAC;IAAEe,CAAC,GAAG3B,IAAI,CAAC4B,MAAM;EAC3B,OAAO,EAAEhB,CAAC,GAAGe,CAAC,EAAE;IACZ,IAAI/B,OAAO,CAAC6B,KAAK,GAAGzB,IAAI,CAACY,CAAC,CAAC,CAAC,EAAE;MAC1Bc,CAAC,GAAGR,gBAAgB,CAACnB,IAAI,EAAE0B,KAAK,EAAEF,GAAG,EAAEG,CAAC,CAAC,CAACE,MAAM;KACnD,MAAM,IAAIH,KAAK,YAAY9B,OAAO,EAAE;MACjC+B,CAAC,GAAGR,gBAAgB,CAACnB,IAAI,EAAE0B,KAAK,CAACI,MAAM,EAAEN,GAAG,EAAEG,CAAC,CAAC,CAACE,MAAM;KAC1D,MAAM,IAAIH,KAAK,YAAY1B,IAAI,EAAE;MAAEwB,GAAG,CAACG,CAAC,EAAE,CAAC,GAAGD,KAAK;;;EAExD,OAAOF,GAAG;AACd;AAEA;AACA,SAASH,yBAAyBA,CAAmBrB,IAAqB,EAAEC,IAAW,EAAEuB,GAAQ,EAAEC,GAAW;EAC1G,IAAIC,KAAU;IAAEC,CAAC,GAAGF,GAAG;EACvB,IAAIZ,CAAC,GAAG,CAAC,CAAC;IAAEe,CAAC,GAAG3B,IAAI,CAAC4B,MAAM;EAC3B,OAAO,EAAEhB,CAAC,GAAGe,CAAC,EAAE;IACZ,IAAI/B,OAAO,CAAC6B,KAAK,GAAGzB,IAAI,CAACY,CAAC,CAAC,CAAC,EAAE;MAC1Bc,CAAC,GAAGN,yBAAyB,CAACrB,IAAI,EAAE0B,KAAK,EAAEF,GAAG,EAAEG,CAAC,CAAC,CAACE,MAAM;KAC5D,MAAM,IAAIH,KAAK,YAAY1B,IAAI,EAAE;MAC9B2B,CAAC,GAAGzB,WAAW,CAACR,MAAM,EAAEgC,KAAK,CAACK,MAAM,CAACtB,MAAM,CAACE,GAAG,CAAC,UAACqB,CAAC,EAAEnB,CAAC;QAAA,OAAKa,KAAK,CAACO,UAAU,CAACpB,CAAC,CAAE;MAAA,EAAC,EAAEW,GAAG,EAAEG,CAAC,CAAC,CAACE,MAAM;KAClG,MAAM,IAAIH,KAAK,YAAYhC,MAAM,EAAE;MAAE8B,GAAG,CAACG,CAAC,EAAE,CAAC,GAAGD,KAAU;;;EAE/D,OAAOF,GAAG;AACd;AAEA;AACA,SAASD,yBAAyBA,CAAmBvB,IAAqB,EAAEC,IAAW,EAAEuB,GAAQ,EAAEC,GAAW;EAC1G,IAAIC,KAAU;IAAEC,CAAC,GAAGF,GAAG;EACvB,IAAIZ,CAAC,GAAG,CAAC,CAAC;IAAEe,CAAC,GAAG3B,IAAI,CAAC4B,MAAM;EAC3B,OAAO,EAAEhB,CAAC,GAAGe,CAAC,EAAE;IACZ,IAAI/B,OAAO,CAAC6B,KAAK,GAAGzB,IAAI,CAACY,CAAC,CAAC,CAAC,EAAE;MAC1Bc,CAAC,GAAGJ,yBAAyB,CAACvB,IAAI,EAAE0B,KAAK,EAAEF,GAAG,EAAEG,CAAC,CAAC,CAACE,MAAM;KAC5D,MAAM,IAAIH,KAAK,YAAY1B,IAAI,EAAE;MAC9B2B,CAAC,GAAGzB,WAAW,CAACT,MAAM,EAAEiC,KAAK,CAACK,MAAM,CAACtB,MAAM,CAACE,GAAG,CAAC,UAACuB,CAAC,EAAErB,CAAC;QAAA,OAAKpB,MAAM,CAACqB,GAAG,CAACoB,CAAC,EAAER,KAAK,CAACO,UAAU,CAACpB,CAAC,CAAE,CAAC;MAAA,EAAC,EAAEW,GAAG,EAAEG,CAAC,CAAC,CAACE,MAAM;KACjH,MAAM,IAAIH,KAAK,YAAYjC,MAAM,EAAE;MAAE+B,GAAG,CAACG,CAAC,EAAE,CAAC,GAAGD,KAAU;;;EAE/D,OAAOF,GAAG;AACd;AAEA;AACA,IAAMW,eAAe,GAAG,SAAlBA,eAAeA,CAAIC,EAAkB,EAAAC,IAAA,EAAsBxB,CAAS;EAAA,IAAAyB,KAAA,GAAA9B,cAAA,CAAA6B,IAAA;IAA5BE,CAAC,GAAAD,KAAA;IAAEE,CAAC,GAAAF,KAAA;EAAA,OAA8BF,EAAE,CAAC,CAAC,CAAC,CAACvB,CAAC,CAAC,GAAG0B,CAAC,EAAEH,EAAE,CAAC,CAAC,CAAC,CAACvB,CAAC,CAAC,GAAG2B,CAAC,EAAEJ,EAAE;AAAA,CAAC;AAE/G;AACA,SAAS9B,gBAAgBA,CAAwCL,IAAW,EAAEwC,GAAgD;EAC1H,IAAIC,IAAW,EAAEd,CAAS;EAC1B,QAAQA,CAAC,GAAG3B,IAAI,CAAC4B,MAAM;IACnB,KAAK,CAAC;MAAE,OAAOY,GAAG;IAClB,KAAK,CAAC;MACFC,IAAI,GAAGD,GAAG,CAAC,CAAC,CAAC;MACb,IAAI,CAAExC,IAAI,CAAC,CAAC,CAAE,EAAE;QAAE,OAAOwC,GAAG;;MAC5B,IAAI5C,OAAO,CAACI,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;QAAE,OAAOK,gBAAgB,CAACL,IAAI,CAAC,CAAC,CAAC,EAAEwC,GAAG,CAAC;;MAC7D,IAAI,EAAExC,IAAI,CAAC,CAAC,CAAC,YAAYV,IAAI,IAAIU,IAAI,CAAC,CAAC,CAAC,YAAYP,MAAM,IAAIO,IAAI,CAAC,CAAC,CAAC,YAAYN,QAAQ,CAAC,EAAE;QAAA,IAAAgD,qBAAA,GACzEC,MAAM,CAACC,OAAO,CAAC5C,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC6C,MAAM,CAACX,eAAe,EAAEM,GAAG,CAAC;QAAA,IAAAM,sBAAA,GAAAvC,cAAA,CAAAmC,qBAAA;QAAlED,IAAI,GAAAK,sBAAA;QAAE9C,IAAI,GAAA8C,sBAAA;;MAEf;IACJ;MACI,CAAClD,OAAO,CAAC6C,IAAI,GAAGzC,IAAI,CAAC2B,CAAC,GAAG,CAAC,CAAC,CAAC,IACrB3B,IAAI,GAAGJ,OAAO,CAACI,IAAI,CAAC,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,EAAEyC,IAAI,GAAG,EAAE,IACnDzC,IAAI,GAAGJ,OAAO,CAACI,IAAI,CAAC,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC+C,KAAK,CAAC,CAAC,EAAEpB,CAAC,GAAG,CAAC,CAAE;;EAGxE,IAAIqB,UAAU,GAAG,CAAC,CAAC;EACnB,IAAIC,UAAU,GAAG,CAAC,CAAC;EACnB,IAAIzB,GAAG,GAAG,CAAC,CAAC;IAAE0B,GAAG,GAAGlD,IAAI,CAAC4B,MAAM;EAC/B,IAAId,KAA0C;EAC9C,IAAIqC,GAA0C;EAC9C,IAAAC,IAAA,GAAA7C,cAAA,CAAuBiC,GAAmC;IAArDhC,MAAM,GAAA4C,IAAA;IAAE3C,MAAM,GAAA2C,IAAA;EAEnB,OAAO,EAAE5B,GAAG,GAAG0B,GAAG,EAAE;IAChBC,GAAG,GAAGnD,IAAI,CAACwB,GAAG,CAAC;IACf,IAAI2B,GAAG,YAAY3D,MAAM,KAAKiB,MAAM,CAAC,EAAEwC,UAAU,CAAC,GAAGE,GAAG,CAAC,EAAE;MACvD3C,MAAM,CAAC,EAAEwC,UAAU,CAAC,GAAGG,GAAG,CAACrC,KAAK,CAACC,KAAK,CAAC0B,IAAI,CAACjB,GAAG,CAAC,EAAE2B,GAAG,CAACE,IAAI,EAAE,IAAI,CAAC;KACpE,MAAM;MAAA,IAAAC,KAAA,GACuBb,IAAI;MAAA,IAAAc,SAAA,GAAAD,KAAA,CAA1B9B,GAAG;MAAGV,KAAK,GAAAyC,SAAA,cAAG/B,GAAG,GAAA+B,SAAA;MACrB,IAAIJ,GAAG,YAAYzD,QAAQ,KAAKe,MAAM,CAAC,EAAEwC,UAAU,CAAC,GAAGE,GAAG,CAAC,EAAE;QACzD3C,MAAM,CAAC,EAAEwC,UAAU,CAAC,GAAGzD,KAAK,CAACsB,GAAG,CAACC,KAAK,EAAEqC,GAAe,EAAE,IAAI,CAAsB;OACtF,MAAM,IAAIA,GAAG,IAAIA,GAAG,CAACE,IAAI,KAAK5C,MAAM,CAAC,EAAEwC,UAAU,CAAC,GAAGE,GAAG,CAAC,EAAE;QACxDA,GAAG,YAAY7D,IAAI,KAAKmB,MAAM,CAACwC,UAAU,CAAC,GAAGE,GAAG,GAAG1D,MAAM,CAACoB,GAAG,CAACsC,GAAG,CAAW,CAAC;QAC7E3C,MAAM,CAAC,EAAEwC,UAAU,CAAC,GAAGzD,KAAK,CAACsB,GAAG,CAACC,KAAK,EAAEqC,GAAG,CAACE,IAAI,EAAE,IAAI,CAAsB;;;;EAIxF,OAAOb,GAAG;AACd"},"metadata":{},"sourceType":"module"}