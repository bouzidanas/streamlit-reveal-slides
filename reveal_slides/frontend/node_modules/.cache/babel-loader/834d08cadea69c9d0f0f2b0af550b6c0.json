{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/anasbouzid/streamlit/streamlit.io/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/home/anasbouzid/streamlit/streamlit.io/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/anasbouzid/streamlit/streamlit.io/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/anasbouzid/streamlit/streamlit.io/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"/home/anasbouzid/streamlit/streamlit.io/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/home/anasbouzid/streamlit/streamlit.io/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _awaitAsyncGenerator from \"/home/anasbouzid/streamlit/streamlit.io/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/home/anasbouzid/streamlit/streamlit.io/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(_fromIterable);\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { toUint8Array, joinUint8Arrays, toUint8ArrayIterator, toUint8ArrayAsyncIterator } from '../util/buffer';\n/** @ignore */\nexport default {\n  fromIterable: function fromIterable(source) {\n    return pump(_fromIterable(source));\n  },\n  fromAsyncIterable: function fromAsyncIterable(source) {\n    return pump(_fromAsyncIterable2(source));\n  },\n  fromDOMStream: function fromDOMStream(source) {\n    return pump(_fromDOMStream2(source));\n  },\n  fromNodeStream: function fromNodeStream(stream) {\n    return pump(_fromNodeStream2(stream));\n  },\n  // @ts-ignore\n  toDOMStream: function toDOMStream(source, options) {\n    throw new Error(\"\\\"toDOMStream\\\" not available in this environment\");\n  },\n  // @ts-ignore\n  toNodeStream: function toNodeStream(source, options) {\n    throw new Error(\"\\\"toNodeStream\\\" not available in this environment\");\n  }\n};\n/** @ignore */\nvar pump = function pump(iterator) {\n  iterator.next();\n  return iterator;\n};\n/** @ignore */\nfunction _fromIterable(source) {\n  var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield, it, _ref, _yield$byteRange;\n  return _regeneratorRuntime().wrap(function _fromIterable$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        byteRange = function _byteRange() {\n          if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n          }\n          var _joinUint8Arrays = joinUint8Arrays(buffers, size);\n          var _joinUint8Arrays2 = _slicedToArray(_joinUint8Arrays, 3);\n          buffer = _joinUint8Arrays2[0];\n          buffers = _joinUint8Arrays2[1];\n          bufferLength = _joinUint8Arrays2[2];\n          return buffer;\n        };\n        threw = false;\n        buffers = [];\n        bufferLength = 0;\n        _context.next = 6;\n        return null;\n      case 6:\n        _yield = _context.sent;\n        cmd = _yield.cmd;\n        size = _yield.size;\n        // initialize the iterator\n        it = toUint8ArrayIterator(source)[Symbol.iterator]();\n        _context.prev = 10;\n      case 11:\n        // read the next value\n        // if chunk is not null or empty, push it onto the queue\n        _ref = isNaN(size - bufferLength) ? it.next(undefined) : it.next(size - bufferLength);\n        done = _ref.done;\n        buffer = _ref.value;\n        if (!done && buffer.byteLength > 0) {\n          buffers.push(buffer);\n          bufferLength += buffer.byteLength;\n        }\n        // If we have enough bytes in our buffer, yield chunks until we don't\n        if (!(done || size <= bufferLength)) {\n          _context.next = 22;\n          break;\n        }\n      case 16:\n        _context.next = 18;\n        return byteRange();\n      case 18:\n        _yield$byteRange = _context.sent;\n        cmd = _yield$byteRange.cmd;\n        size = _yield$byteRange.size;\n      case 21:\n        if (size < bufferLength) {\n          _context.next = 16;\n          break;\n        }\n      case 22:\n        if (!done) {\n          _context.next = 11;\n          break;\n        }\n      case 23:\n        _context.next = 28;\n        break;\n      case 25:\n        _context.prev = 25;\n        _context.t0 = _context[\"catch\"](10);\n        (threw = true) && typeof it.throw === 'function' && it.throw(_context.t0);\n      case 28:\n        _context.prev = 28;\n        threw === false && typeof it.return === 'function' && it.return();\n        return _context.finish(28);\n      case 31:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _marked, null, [[10, 25, 28, 31]]);\n}\n/** @ignore */\nfunction _fromAsyncIterable2(_x) {\n  return _fromAsyncIterable.apply(this, arguments);\n} // All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nfunction _fromAsyncIterable() {\n  _fromAsyncIterable = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n    var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield2, it, _ref2, _yield$byteRange2;\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          byteRange = function _byteRange2() {\n            if (cmd === 'peek') {\n              return joinUint8Arrays(buffers, size)[0];\n            }\n            var _joinUint8Arrays3 = joinUint8Arrays(buffers, size);\n            var _joinUint8Arrays4 = _slicedToArray(_joinUint8Arrays3, 3);\n            buffer = _joinUint8Arrays4[0];\n            buffers = _joinUint8Arrays4[1];\n            bufferLength = _joinUint8Arrays4[2];\n            return buffer;\n          };\n          threw = false;\n          buffers = [];\n          bufferLength = 0;\n          _context2.next = 6;\n          return null;\n        case 6:\n          _yield2 = _context2.sent;\n          cmd = _yield2.cmd;\n          size = _yield2.size;\n          // initialize the iterator\n          it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n          _context2.prev = 10;\n        case 11:\n          if (!isNaN(size - bufferLength)) {\n            _context2.next = 17;\n            break;\n          }\n          _context2.next = 14;\n          return _awaitAsyncGenerator(it.next(undefined));\n        case 14:\n          _context2.t0 = _context2.sent;\n          _context2.next = 20;\n          break;\n        case 17:\n          _context2.next = 19;\n          return _awaitAsyncGenerator(it.next(size - bufferLength));\n        case 19:\n          _context2.t0 = _context2.sent;\n        case 20:\n          _ref2 = _context2.t0;\n          done = _ref2.done;\n          buffer = _ref2.value;\n          // if chunk is not null or empty, push it onto the queue\n          if (!done && buffer.byteLength > 0) {\n            buffers.push(buffer);\n            bufferLength += buffer.byteLength;\n          }\n          // If we have enough bytes in our buffer, yield chunks until we don't\n          if (!(done || size <= bufferLength)) {\n            _context2.next = 31;\n            break;\n          }\n        case 25:\n          _context2.next = 27;\n          return byteRange();\n        case 27:\n          _yield$byteRange2 = _context2.sent;\n          cmd = _yield$byteRange2.cmd;\n          size = _yield$byteRange2.size;\n        case 30:\n          if (size < bufferLength) {\n            _context2.next = 25;\n            break;\n          }\n        case 31:\n          if (!done) {\n            _context2.next = 11;\n            break;\n          }\n        case 32:\n          _context2.next = 40;\n          break;\n        case 34:\n          _context2.prev = 34;\n          _context2.t1 = _context2[\"catch\"](10);\n          _context2.t2 = (threw = true) && typeof it.throw === 'function';\n          if (!_context2.t2) {\n            _context2.next = 40;\n            break;\n          }\n          _context2.next = 40;\n          return _awaitAsyncGenerator(it.throw(_context2.t1));\n        case 40:\n          _context2.prev = 40;\n          _context2.t3 = threw === false && typeof it.return === 'function';\n          if (!_context2.t3) {\n            _context2.next = 45;\n            break;\n          }\n          _context2.next = 45;\n          return _awaitAsyncGenerator(it.return());\n        case 45:\n          return _context2.finish(40);\n        case 46:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee, null, [[10, 34, 40, 46]]);\n  }));\n  return _fromAsyncIterable.apply(this, arguments);\n}\nfunction _fromDOMStream2(_x2) {\n  return _fromDOMStream.apply(this, arguments);\n}\n/** @ignore */\nfunction _fromDOMStream() {\n  _fromDOMStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(source) {\n    var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield3, it, _ref3, _yield$byteRange3;\n    return _regeneratorRuntime().wrap(function _callee2$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          byteRange = function _byteRange3() {\n            if (cmd === 'peek') {\n              return joinUint8Arrays(buffers, size)[0];\n            }\n            var _joinUint8Arrays5 = joinUint8Arrays(buffers, size);\n            var _joinUint8Arrays6 = _slicedToArray(_joinUint8Arrays5, 3);\n            buffer = _joinUint8Arrays6[0];\n            buffers = _joinUint8Arrays6[1];\n            bufferLength = _joinUint8Arrays6[2];\n            return buffer;\n          };\n          done = false, threw = false;\n          buffers = [];\n          bufferLength = 0;\n          _context3.next = 6;\n          return null;\n        case 6:\n          _yield3 = _context3.sent;\n          cmd = _yield3.cmd;\n          size = _yield3.size;\n          // initialize the reader and lock the stream\n          it = new AdaptiveByteReader(source);\n          _context3.prev = 10;\n        case 11:\n          if (!isNaN(size - bufferLength)) {\n            _context3.next = 17;\n            break;\n          }\n          _context3.next = 14;\n          return _awaitAsyncGenerator(it['read'](undefined));\n        case 14:\n          _context3.t0 = _context3.sent;\n          _context3.next = 20;\n          break;\n        case 17:\n          _context3.next = 19;\n          return _awaitAsyncGenerator(it['read'](size - bufferLength));\n        case 19:\n          _context3.t0 = _context3.sent;\n        case 20:\n          _ref3 = _context3.t0;\n          done = _ref3.done;\n          buffer = _ref3.value;\n          // if chunk is not null or empty, push it onto the queue\n          if (!done && buffer.byteLength > 0) {\n            buffers.push(toUint8Array(buffer));\n            bufferLength += buffer.byteLength;\n          }\n          // If we have enough bytes in our buffer, yield chunks until we don't\n          if (!(done || size <= bufferLength)) {\n            _context3.next = 31;\n            break;\n          }\n        case 25:\n          _context3.next = 27;\n          return byteRange();\n        case 27:\n          _yield$byteRange3 = _context3.sent;\n          cmd = _yield$byteRange3.cmd;\n          size = _yield$byteRange3.size;\n        case 30:\n          if (size < bufferLength) {\n            _context3.next = 25;\n            break;\n          }\n        case 31:\n          if (!done) {\n            _context3.next = 11;\n            break;\n          }\n        case 32:\n          _context3.next = 40;\n          break;\n        case 34:\n          _context3.prev = 34;\n          _context3.t1 = _context3[\"catch\"](10);\n          _context3.t2 = threw = true;\n          if (!_context3.t2) {\n            _context3.next = 40;\n            break;\n          }\n          _context3.next = 40;\n          return _awaitAsyncGenerator(it['cancel'](_context3.t1));\n        case 40:\n          _context3.prev = 40;\n          if (!(threw === false)) {\n            _context3.next = 46;\n            break;\n          }\n          _context3.next = 44;\n          return _awaitAsyncGenerator(it['cancel']());\n        case 44:\n          _context3.next = 47;\n          break;\n        case 46:\n          source['locked'] && it.releaseLock();\n        case 47:\n          return _context3.finish(40);\n        case 48:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee2, null, [[10, 34, 40, 48]]);\n  }));\n  return _fromDOMStream.apply(this, arguments);\n}\nvar AdaptiveByteReader = /*#__PURE__*/function () {\n  function AdaptiveByteReader(source) {\n    _classCallCheck(this, AdaptiveByteReader);\n    this.source = source;\n    this.byobReader = null;\n    this.defaultReader = null;\n    try {\n      this.supportsBYOB = !!(this.reader = this.getBYOBReader());\n    } catch (e) {\n      this.supportsBYOB = !!!(this.reader = this.getDefaultReader());\n    }\n  }\n  _createClass(AdaptiveByteReader, [{\n    key: \"closed\",\n    get: function get() {\n      return this.reader ? this.reader['closed'].catch(function () {}) : Promise.resolve();\n    }\n  }, {\n    key: \"releaseLock\",\n    value: function releaseLock() {\n      if (this.reader) {\n        this.reader.releaseLock();\n      }\n      this.reader = this.byobReader = this.defaultReader = null;\n    }\n  }, {\n    key: \"cancel\",\n    value: function () {\n      var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(reason) {\n        var reader, source;\n        return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              reader = this.reader, source = this.source;\n              _context4.t0 = reader;\n              if (!_context4.t0) {\n                _context4.next = 5;\n                break;\n              }\n              _context4.next = 5;\n              return reader['cancel'](reason).catch(function () {});\n            case 5:\n              source && source['locked'] && this.releaseLock();\n            case 6:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee3, this);\n      }));\n      function cancel(_x4) {\n        return _cancel.apply(this, arguments);\n      }\n      return cancel;\n    }()\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(size) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!(size === 0)) {\n                _context5.next = 2;\n                break;\n              }\n              return _context5.abrupt(\"return\", {\n                done: this.reader == null,\n                value: new Uint8Array(0)\n              });\n            case 2:\n              if (!(!this.supportsBYOB || typeof size !== 'number')) {\n                _context5.next = 8;\n                break;\n              }\n              _context5.next = 5;\n              return this.getDefaultReader().read();\n            case 5:\n              _context5.t0 = _context5.sent;\n              _context5.next = 11;\n              break;\n            case 8:\n              _context5.next = 10;\n              return this.readFromBYOBReader(size);\n            case 10:\n              _context5.t0 = _context5.sent;\n            case 11:\n              result = _context5.t0;\n              !result.done && (result.value = toUint8Array(result));\n              return _context5.abrupt(\"return\", result);\n            case 14:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee4, this);\n      }));\n      function read(_x5) {\n        return _read.apply(this, arguments);\n      }\n      return read;\n    }()\n  }, {\n    key: \"getDefaultReader\",\n    value: function getDefaultReader() {\n      if (this.byobReader) {\n        this.releaseLock();\n      }\n      if (!this.defaultReader) {\n        this.defaultReader = this.source['getReader']();\n        // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n        // about why these errors are raised, but I'm sure there's some important spec reason that\n        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n        // only solution in this case :/\n        this.defaultReader['closed'].catch(function () {});\n      }\n      return this.reader = this.defaultReader;\n    }\n  }, {\n    key: \"getBYOBReader\",\n    value: function getBYOBReader() {\n      if (this.defaultReader) {\n        this.releaseLock();\n      }\n      if (!this.byobReader) {\n        this.byobReader = this.source['getReader']({\n          mode: 'byob'\n        });\n        // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n        // about why these errors are raised, but I'm sure there's some important spec reason that\n        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n        // only solution in this case :/\n        this.byobReader['closed'].catch(function () {});\n      }\n      return this.reader = this.byobReader;\n    }\n    // This strategy plucked from the example in the streams spec:\n    // https://streams.spec.whatwg.org/#example-manual-read-bytes\n  }, {\n    key: \"readFromBYOBReader\",\n    value: function () {\n      var _readFromBYOBReader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(size) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return readInto(this.getBYOBReader(), new ArrayBuffer(size), 0, size);\n            case 2:\n              return _context6.abrupt(\"return\", _context6.sent);\n            case 3:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee5, this);\n      }));\n      function readFromBYOBReader(_x6) {\n        return _readFromBYOBReader.apply(this, arguments);\n      }\n      return readFromBYOBReader;\n    }()\n  }]);\n  return AdaptiveByteReader;\n}();\n/** @ignore */\nfunction readInto(_x7, _x8, _x9, _x10) {\n  return _readInto.apply(this, arguments);\n}\n/** @ignore */\nfunction _readInto() {\n  _readInto = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(reader, buffer, offset, size) {\n    var _yield$reader$read, done, value;\n    return _regeneratorRuntime().wrap(function _callee8$(_context9) {\n      while (1) switch (_context9.prev = _context9.next) {\n        case 0:\n          if (!(offset >= size)) {\n            _context9.next = 2;\n            break;\n          }\n          return _context9.abrupt(\"return\", {\n            done: false,\n            value: new Uint8Array(buffer, 0, size)\n          });\n        case 2:\n          _context9.next = 4;\n          return reader.read(new Uint8Array(buffer, offset, size - offset));\n        case 4:\n          _yield$reader$read = _context9.sent;\n          done = _yield$reader$read.done;\n          value = _yield$reader$read.value;\n          if (!((offset += value.byteLength) < size && !done)) {\n            _context9.next = 11;\n            break;\n          }\n          _context9.next = 10;\n          return readInto(reader, value.buffer, offset, size);\n        case 10:\n          return _context9.abrupt(\"return\", _context9.sent);\n        case 11:\n          return _context9.abrupt(\"return\", {\n            done: done,\n            value: new Uint8Array(value.buffer, 0, offset)\n          });\n        case 12:\n        case \"end\":\n          return _context9.stop();\n      }\n    }, _callee8);\n  }));\n  return _readInto.apply(this, arguments);\n}\nvar onEvent = function onEvent(stream, event) {\n  var handler = function handler(_) {\n    return resolve([event, _]);\n  };\n  var resolve;\n  return [event, handler, new Promise(function (r) {\n    return (resolve = r) && stream['once'](event, handler);\n  })];\n};\n/** @ignore */\nfunction _fromNodeStream2(_x3) {\n  return _fromNodeStream.apply(this, arguments);\n}\nfunction _fromNodeStream() {\n  _fromNodeStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(stream) {\n    var events, event, done, err, cmd, size, bufferLength, buffers, buffer, byteRange, _yield4, _yield$_awaitAsyncGen, _yield$_awaitAsyncGen2, _yield$byteRange4, cleanup;\n    return _regeneratorRuntime().wrap(function _callee7$(_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          cleanup = function _cleanup(events, err) {\n            buffer = buffers = null;\n            return new Promise( /*#__PURE__*/function () {\n              var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(resolve, reject) {\n                var _iterator, _step, _step$value, evt, fn, destroy;\n                return _regeneratorRuntime().wrap(function _callee6$(_context7) {\n                  while (1) switch (_context7.prev = _context7.next) {\n                    case 0:\n                      _iterator = _createForOfIteratorHelper(events);\n                      try {\n                        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                          _step$value = _slicedToArray(_step.value, 2), evt = _step$value[0], fn = _step$value[1];\n                          stream['off'](evt, fn);\n                        }\n                      } catch (err) {\n                        _iterator.e(err);\n                      } finally {\n                        _iterator.f();\n                      }\n                      try {\n                        // Some stream implementations don't call the destroy callback,\n                        // because it's really a node-internal API. Just calling `destroy`\n                        // here should be enough to conform to the ReadableStream contract\n                        destroy = stream['destroy'];\n                        destroy && destroy.call(stream, err);\n                        err = undefined;\n                      } catch (e) {\n                        err = e || err;\n                      } finally {\n                        err != null ? reject(err) : resolve();\n                      }\n                    case 3:\n                    case \"end\":\n                      return _context7.stop();\n                  }\n                }, _callee6);\n              }));\n              return function (_x11, _x12) {\n                return _ref4.apply(this, arguments);\n              };\n            }());\n          };\n          byteRange = function _byteRange4() {\n            if (cmd === 'peek') {\n              return joinUint8Arrays(buffers, size)[0];\n            }\n            var _joinUint8Arrays7 = joinUint8Arrays(buffers, size);\n            var _joinUint8Arrays8 = _slicedToArray(_joinUint8Arrays7, 3);\n            buffer = _joinUint8Arrays8[0];\n            buffers = _joinUint8Arrays8[1];\n            bufferLength = _joinUint8Arrays8[2];\n            return buffer;\n          };\n          events = [];\n          event = 'error';\n          done = false, err = null;\n          bufferLength = 0;\n          buffers = [];\n          _context8.next = 9;\n          return null;\n        case 9:\n          _yield4 = _context8.sent;\n          cmd = _yield4.cmd;\n          size = _yield4.size;\n          if (!stream['isTTY']) {\n            _context8.next = 16;\n            break;\n          }\n          _context8.next = 15;\n          return new Uint8Array(0);\n        case 15:\n          return _context8.abrupt(\"return\", _context8.sent);\n        case 16:\n          _context8.prev = 16;\n          // initialize the stream event handlers\n          events[0] = onEvent(stream, 'end');\n          events[1] = onEvent(stream, 'error');\n        case 19:\n          events[2] = onEvent(stream, 'readable');\n          // wait on the first message event from the stream\n          _context8.next = 22;\n          return _awaitAsyncGenerator(Promise.race(events.map(function (x) {\n            return x[2];\n          })));\n        case 22:\n          _yield$_awaitAsyncGen = _context8.sent;\n          _yield$_awaitAsyncGen2 = _slicedToArray(_yield$_awaitAsyncGen, 2);\n          event = _yield$_awaitAsyncGen2[0];\n          err = _yield$_awaitAsyncGen2[1];\n          if (!(event === 'error')) {\n            _context8.next = 28;\n            break;\n          }\n          return _context8.abrupt(\"break\", 37);\n        case 28:\n          if (!(done = event === 'end')) {\n            // If the size is NaN, request to read everything in the stream's internal buffer\n            if (!isFinite(size - bufferLength)) {\n              buffer = toUint8Array(stream['read'](undefined));\n            } else {\n              buffer = toUint8Array(stream['read'](size - bufferLength));\n              // If the byteLength is 0, then the requested amount is more than the stream has\n              // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n              // continue emitting readable events, so request to read everything the stream\n              // has in its internal buffer right now.\n              if (buffer.byteLength < size - bufferLength) {\n                buffer = toUint8Array(stream['read'](undefined));\n              }\n            }\n            // if chunk is not null or empty, push it onto the queue\n            if (buffer.byteLength > 0) {\n              buffers.push(buffer);\n              bufferLength += buffer.byteLength;\n            }\n          }\n          // If we have enough bytes in our buffer, yield chunks until we don't\n          if (!(done || size <= bufferLength)) {\n            _context8.next = 36;\n            break;\n          }\n        case 30:\n          _context8.next = 32;\n          return byteRange();\n        case 32:\n          _yield$byteRange4 = _context8.sent;\n          cmd = _yield$byteRange4.cmd;\n          size = _yield$byteRange4.size;\n        case 35:\n          if (size < bufferLength) {\n            _context8.next = 30;\n            break;\n          }\n        case 36:\n          if (!done) {\n            _context8.next = 19;\n            break;\n          }\n        case 37:\n          _context8.prev = 37;\n          _context8.next = 40;\n          return _awaitAsyncGenerator(cleanup(events, event === 'error' ? err : null));\n        case 40:\n          return _context8.finish(37);\n        case 41:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, _callee7, null, [[16,, 37, 41]]);\n  }));\n  return _fromNodeStream.apply(this, arguments);\n}","map":{"version":3,"names":["fromIterable","toUint8Array","joinUint8Arrays","toUint8ArrayIterator","toUint8ArrayAsyncIterator","source","pump","fromAsyncIterable","fromDOMStream","fromNodeStream","stream","toDOMStream","options","Error","toNodeStream","iterator","next","done","threw","buffers","buffer","cmd","size","bufferLength","byteRange","_yield","it","_ref","_yield$byteRange","_regeneratorRuntime","wrap","_fromIterable$","_context","prev","_byteRange","_joinUint8Arrays","_joinUint8Arrays2","_slicedToArray","sent","Symbol","isNaN","undefined","value","byteLength","push","t0","throw","return","finish","stop","_marked","_x","_fromAsyncIterable","apply","arguments","_wrapAsyncGenerator","mark","_callee","_yield2","_ref2","_yield$byteRange2","_callee$","_context2","_byteRange2","_joinUint8Arrays3","_joinUint8Arrays4","asyncIterator","_awaitAsyncGenerator","t1","t2","t3","_x2","_fromDOMStream","_callee2","_yield3","_ref3","_yield$byteRange3","_callee2$","_context3","_byteRange3","_joinUint8Arrays5","_joinUint8Arrays6","AdaptiveByteReader","releaseLock","_classCallCheck","byobReader","defaultReader","supportsBYOB","reader","getBYOBReader","e","getDefaultReader","_createClass","key","get","catch","Promise","resolve","_cancel","_asyncToGenerator","_callee3","reason","_callee3$","_context4","cancel","_x4","_read","_callee4","result","_callee4$","_context5","abrupt","Uint8Array","read","readFromBYOBReader","_x5","mode","_readFromBYOBReader","_callee5","_callee5$","_context6","readInto","ArrayBuffer","_x6","_x7","_x8","_x9","_x10","_readInto","_callee8","offset","_yield$reader$read","_callee8$","_context9","onEvent","event","handler","_","r","_x3","_fromNodeStream","_callee7","events","err","_yield4","_yield$_awaitAsyncGen","_yield$_awaitAsyncGen2","_yield$byteRange4","cleanup","_callee7$","_context8","_cleanup","_ref4","_callee6","reject","_iterator","_step","_step$value","evt","fn","destroy","_callee6$","_context7","_createForOfIteratorHelper","s","n","f","call","_x11","_x12","_byteRange4","_joinUint8Arrays7","_joinUint8Arrays8","race","map","x","isFinite"],"sources":["io/adapters.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport {\n    toUint8Array,\n    joinUint8Arrays,\n    ArrayBufferViewInput,\n    toUint8ArrayIterator,\n    toUint8ArrayAsyncIterator\n} from '../util/buffer';\n\nimport { ReadableDOMStreamOptions } from './interfaces';\n\n/** @ignore */\nexport default {\n    fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): IterableIterator<Uint8Array> {\n        return pump(fromIterable<T>(source));\n    },\n    fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncIterableIterator<Uint8Array> {\n        return pump(fromAsyncIterable<T>(source));\n    },\n    fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncIterableIterator<Uint8Array> {\n        return pump(fromDOMStream<T>(source));\n    },\n    fromNodeStream(stream: NodeJS.ReadableStream): AsyncIterableIterator<Uint8Array> {\n        return pump(fromNodeStream(stream));\n    },\n    // @ts-ignore\n    toDOMStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: ReadableDOMStreamOptions): ReadableStream<T> {\n        throw new Error(`\"toDOMStream\" not available in this environment`);\n    },\n    // @ts-ignore\n    toNodeStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: import('stream').ReadableOptions): import('stream').Readable {\n        throw new Error(`\"toNodeStream\" not available in this environment`);\n    },\n};\n\n/** @ignore */\nconst pump = <T extends Iterator<any> | AsyncIterator<any>>(iterator: T) => { iterator.next(); return iterator; };\n\n/** @ignore */\nfunction* fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): IterableIterator<Uint8Array> {\n\n    let done: boolean, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source Iterator\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the iterator\n    let it = toUint8ArrayIterator(source)[Symbol.iterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength) ?\n                it.next(undefined) : it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (it.return());\n    }\n}\n\n/** @ignore */\nasync function* fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncIterableIterator<Uint8Array> {\n\n    let done: boolean, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source AsyncIterator\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the iterator\n    let it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength)\n                ? await it.next(undefined)\n                : await it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (await it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (await it.return());\n    }\n}\n\n// All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nasync function* fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncIterableIterator<Uint8Array> {\n\n    let done = false, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we establish the ReadableStream lock\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the reader and lock the stream\n    let it = new AdaptiveByteReader(source);\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength)\n                ? await it['read'](undefined)\n                : await it['read'](size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(toUint8Array(buffer));\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (await it['cancel'](e));\n    } finally {\n        (threw === false) ? (await it['cancel']())\n            : source['locked'] && it.releaseLock();\n    }\n}\n\n/** @ignore */\nclass AdaptiveByteReader<T extends ArrayBufferViewInput> {\n\n    private supportsBYOB: boolean;\n    private byobReader: ReadableStreamBYOBReader | null = null;\n    private defaultReader: ReadableStreamDefaultReader<T> | null = null;\n    private reader: ReadableStreamBYOBReader | ReadableStreamDefaultReader<T> | null;\n\n    constructor(private source: ReadableStream<T>) {\n        try {\n            this.supportsBYOB = !!(this.reader = this.getBYOBReader());\n        } catch (e) {\n            this.supportsBYOB = !!!(this.reader = this.getDefaultReader());\n        }\n    }\n\n    get closed(): Promise<void> {\n        return this.reader ? this.reader['closed'].catch(() => {}) : Promise.resolve();\n    }\n\n    releaseLock(): void {\n        if (this.reader) {\n            this.reader.releaseLock();\n        }\n        this.reader = this.byobReader = this.defaultReader = null;\n    }\n\n    async cancel(reason?: any): Promise<void> {\n        const { reader, source } = this;\n        reader && (await reader['cancel'](reason).catch(() => {}));\n        source && (source['locked'] && this.releaseLock());\n    }\n\n    async read(size?: number): Promise<ReadableStreamReadResult<Uint8Array>> {\n        if (size === 0) {\n            return { done: this.reader == null, value: new Uint8Array(0) };\n        }\n        const result = !this.supportsBYOB || typeof size !== 'number'\n            ? await this.getDefaultReader().read()\n            : await this.readFromBYOBReader(size);\n        !result.done && (result.value = toUint8Array(result as ReadableStreamReadResult<Uint8Array>));\n        return result as ReadableStreamReadResult<Uint8Array>;\n    }\n\n    private getDefaultReader() {\n        if (this.byobReader) { this.releaseLock(); }\n        if (!this.defaultReader) {\n            this.defaultReader = this.source['getReader']();\n            // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n            // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n            // about why these errors are raised, but I'm sure there's some important spec reason that\n            // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n            // only solution in this case :/\n            this.defaultReader['closed'].catch(() => {});\n        }\n        return (this.reader = this.defaultReader);\n    }\n\n    private getBYOBReader() {\n        if (this.defaultReader) { this.releaseLock(); }\n        if (!this.byobReader) {\n            this.byobReader = this.source['getReader']({ mode: 'byob' });\n            // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n            // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n            // about why these errors are raised, but I'm sure there's some important spec reason that\n            // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n            // only solution in this case :/\n            this.byobReader['closed'].catch(() => {});\n        }\n        return (this.reader = this.byobReader);\n    }\n\n    // This strategy plucked from the example in the streams spec:\n    // https://streams.spec.whatwg.org/#example-manual-read-bytes\n    private async readFromBYOBReader(size: number) {\n        return await readInto(this.getBYOBReader(), new ArrayBuffer(size), 0, size);\n    }\n}\n\n/** @ignore */\nasync function readInto(reader: ReadableStreamBYOBReader, buffer: ArrayBufferLike, offset: number, size: number): Promise<ReadableStreamReadResult<Uint8Array>> {\n    if (offset >= size) {\n        return { done: false, value: new Uint8Array(buffer, 0, size) };\n    }\n    const { done, value } = await reader.read(new Uint8Array(buffer, offset, size - offset));\n    if (((offset += value.byteLength) < size) && !done) {\n        return await readInto(reader, value.buffer, offset, size);\n    }\n    return { done, value: new Uint8Array(value.buffer, 0, offset) };\n}\n\n/** @ignore */\ntype EventName = 'end' | 'error' | 'readable';\n/** @ignore */\ntype Event = [EventName, (_: any) => void, Promise<[EventName, Error | null]>];\n/** @ignore */\nconst onEvent = <T extends string>(stream: NodeJS.ReadableStream, event: T) => {\n    let handler = (_: any) => resolve([event, _]);\n    let resolve: (value?: [T, any] | PromiseLike<[T, any]>) => void;\n    return [event, handler, new Promise<[T, any]>(\n        (r) => (resolve = r) && stream['once'](event, handler)\n    )] as Event;\n};\n\n/** @ignore */\nasync function* fromNodeStream(stream: NodeJS.ReadableStream): AsyncIterableIterator<Uint8Array> {\n\n    let events: Event[] = [];\n    let event: EventName = 'error';\n    let done = false, err: Error | null = null;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array | Buffer | string;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we\n    // add the listener for the source stream's 'readable' event.\n    ({ cmd, size } = yield <any> null);\n\n    // ignore stdin if it's a TTY\n    if ((stream as any)['isTTY']) { return yield new Uint8Array(0); }\n\n    try {\n        // initialize the stream event handlers\n        events[0] = onEvent(stream, 'end');\n        events[1] = onEvent(stream, 'error');\n\n        do {\n            events[2] = onEvent(stream, 'readable');\n\n            // wait on the first message event from the stream\n            [event, err] = await Promise.race(events.map((x) => x[2]));\n\n            // if the stream emitted an Error, rethrow it\n            if (event === 'error') { break; }\n            if (!(done = event === 'end')) {\n                // If the size is NaN, request to read everything in the stream's internal buffer\n                if (!isFinite(size - bufferLength)) {\n                    buffer = toUint8Array(stream['read'](undefined));\n                } else {\n                    buffer = toUint8Array(stream['read'](size - bufferLength));\n                    // If the byteLength is 0, then the requested amount is more than the stream has\n                    // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n                    // continue emitting readable events, so request to read everything the stream\n                    // has in its internal buffer right now.\n                    if (buffer.byteLength < (size - bufferLength)) {\n                        buffer = toUint8Array(stream['read'](undefined));\n                    }\n                }\n                // if chunk is not null or empty, push it onto the queue\n                if (buffer.byteLength > 0) {\n                    buffers.push(buffer);\n                    bufferLength += buffer.byteLength;\n                }\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } finally {\n        await cleanup(events, event === 'error' ? err : null);\n    }\n\n    function cleanup<T extends Error | null | void>(events: Event[], err?: T) {\n        buffer = buffers = <any> null;\n        return new Promise<T>(async (resolve, reject) => {\n            for (const [evt, fn] of events) {\n                stream['off'](evt, fn);\n            }\n            try {\n                // Some stream implementations don't call the destroy callback,\n                // because it's really a node-internal API. Just calling `destroy`\n                // here should be enough to conform to the ReadableStream contract\n                const destroy = (stream as any)['destroy'];\n                destroy && destroy.call(stream, err);\n                err = undefined;\n            } catch (e) { err = e || err; } finally {\n                err != null ? reject(err) : resolve();\n            }\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}