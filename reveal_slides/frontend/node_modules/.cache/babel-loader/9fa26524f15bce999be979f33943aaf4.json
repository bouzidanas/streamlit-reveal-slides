{"ast":null,"code":"import _toConsumableArray from \"/home/anasbouzid/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _construct from \"/home/anasbouzid/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _inherits from \"/home/anasbouzid/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/anasbouzid/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/home/anasbouzid/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/anasbouzid/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { DictionaryVector } from '../vector/dictionary';\n/** @ignore */\nexport var Value = /*#__PURE__*/function () {\n  function Value() {\n    _classCallCheck(this, Value);\n  }\n  _createClass(Value, [{\n    key: \"eq\",\n    value: function eq(other) {\n      if (!(other instanceof Value)) {\n        other = new Literal(other);\n      }\n      return new Equals(this, other);\n    }\n  }, {\n    key: \"le\",\n    value: function le(other) {\n      if (!(other instanceof Value)) {\n        other = new Literal(other);\n      }\n      return new LTeq(this, other);\n    }\n  }, {\n    key: \"ge\",\n    value: function ge(other) {\n      if (!(other instanceof Value)) {\n        other = new Literal(other);\n      }\n      return new GTeq(this, other);\n    }\n  }, {\n    key: \"lt\",\n    value: function lt(other) {\n      return new Not(this.ge(other));\n    }\n  }, {\n    key: \"gt\",\n    value: function gt(other) {\n      return new Not(this.le(other));\n    }\n  }, {\n    key: \"ne\",\n    value: function ne(other) {\n      return new Not(this.eq(other));\n    }\n  }]);\n  return Value;\n}();\n/** @ignore */\nexport var Literal = /*#__PURE__*/function (_Value) {\n  _inherits(Literal, _Value);\n  var _super = _createSuper(Literal);\n  function Literal(v) {\n    var _this;\n    _classCallCheck(this, Literal);\n    _this = _super.call(this);\n    _this.v = v;\n    return _this;\n  }\n  return _createClass(Literal);\n}(Value);\n/** @ignore */\nexport var Col = /*#__PURE__*/function (_Value2) {\n  _inherits(Col, _Value2);\n  var _super2 = _createSuper(Col);\n  function Col(name) {\n    var _this2;\n    _classCallCheck(this, Col);\n    _this2 = _super2.call(this);\n    _this2.name = name;\n    return _this2;\n  }\n  _createClass(Col, [{\n    key: \"bind\",\n    value: function bind(batch) {\n      if (!this.colidx) {\n        // Assume column index doesn't change between calls to bind\n        //this.colidx = cols.findIndex(v => v.name.indexOf(this.name) != -1);\n        this.colidx = -1;\n        var fields = batch.schema.fields;\n        for (var idx = -1; ++idx < fields.length;) {\n          if (fields[idx].name === this.name) {\n            this.colidx = idx;\n            break;\n          }\n        }\n        if (this.colidx < 0) {\n          throw new Error(\"Failed to bind Col \\\"\".concat(this.name, \"\\\"\"));\n        }\n      }\n      var vec = this.vector = batch.getChildAt(this.colidx);\n      return function (idx) {\n        return vec.get(idx);\n      };\n    }\n  }]);\n  return Col;\n}(Value);\n/** @ignore */\nexport var Predicate = /*#__PURE__*/function () {\n  function Predicate() {\n    _classCallCheck(this, Predicate);\n  }\n  _createClass(Predicate, [{\n    key: \"and\",\n    value: function and() {\n      for (var _len = arguments.length, expr = new Array(_len), _key = 0; _key < _len; _key++) {\n        expr[_key] = arguments[_key];\n      }\n      return _construct(And, [this].concat(expr));\n    }\n  }, {\n    key: \"or\",\n    value: function or() {\n      for (var _len2 = arguments.length, expr = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        expr[_key2] = arguments[_key2];\n      }\n      return _construct(Or, [this].concat(expr));\n    }\n  }, {\n    key: \"not\",\n    value: function not() {\n      return new Not(this);\n    }\n  }]);\n  return Predicate;\n}();\n/** @ignore */\nexport var ComparisonPredicate = /*#__PURE__*/function (_Predicate) {\n  _inherits(ComparisonPredicate, _Predicate);\n  var _super3 = _createSuper(ComparisonPredicate);\n  function ComparisonPredicate(left, right) {\n    var _this3;\n    _classCallCheck(this, ComparisonPredicate);\n    _this3 = _super3.call(this);\n    _this3.left = left;\n    _this3.right = right;\n    return _this3;\n  }\n  _createClass(ComparisonPredicate, [{\n    key: \"bind\",\n    value: function bind(batch) {\n      if (this.left instanceof Literal) {\n        if (this.right instanceof Literal) {\n          return this._bindLitLit(batch, this.left, this.right);\n        } else {\n          // right is a Col\n          return this._bindLitCol(batch, this.left, this.right);\n        }\n      } else {\n        // left is a Col\n        if (this.right instanceof Literal) {\n          return this._bindColLit(batch, this.left, this.right);\n        } else {\n          // right is a Col\n          return this._bindColCol(batch, this.left, this.right);\n        }\n      }\n    }\n  }]);\n  return ComparisonPredicate;\n}(Predicate);\n/** @ignore */\nexport var CombinationPredicate = /*#__PURE__*/function (_Predicate2) {\n  _inherits(CombinationPredicate, _Predicate2);\n  var _super4 = _createSuper(CombinationPredicate);\n  function CombinationPredicate() {\n    var _this4;\n    _classCallCheck(this, CombinationPredicate);\n    _this4 = _super4.call(this);\n    for (var _len3 = arguments.length, children = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      children[_key3] = arguments[_key3];\n    }\n    _this4.children = children;\n    return _this4;\n  }\n  return _createClass(CombinationPredicate);\n}(Predicate);\n// add children to prototype so it doesn't get mangled in es2015/umd\nCombinationPredicate.prototype.children = Object.freeze([]); // freeze for safety\n/** @ignore */\nexport var And = /*#__PURE__*/function (_CombinationPredicate) {\n  _inherits(And, _CombinationPredicate);\n  var _super5 = _createSuper(And);\n  function And() {\n    for (var _len4 = arguments.length, children = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      children[_key4] = arguments[_key4];\n    }\n    _classCallCheck(this, And);\n    // Flatten any Ands\n    children = children.reduce(function (accum, p) {\n      return accum.concat(p instanceof And ? p.children : p);\n    }, []);\n    return _super5.call.apply(_super5, [this].concat(_toConsumableArray(children)));\n  }\n  _createClass(And, [{\n    key: \"bind\",\n    value: function bind(batch) {\n      var bound = this.children.map(function (p) {\n        return p.bind(batch);\n      });\n      return function (idx, batch) {\n        return bound.every(function (p) {\n          return p(idx, batch);\n        });\n      };\n    }\n  }]);\n  return And;\n}(CombinationPredicate);\n/** @ignore */\nexport var Or = /*#__PURE__*/function (_CombinationPredicate2) {\n  _inherits(Or, _CombinationPredicate2);\n  var _super6 = _createSuper(Or);\n  function Or() {\n    for (var _len5 = arguments.length, children = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      children[_key5] = arguments[_key5];\n    }\n    _classCallCheck(this, Or);\n    // Flatten any Ors\n    children = children.reduce(function (accum, p) {\n      return accum.concat(p instanceof Or ? p.children : p);\n    }, []);\n    return _super6.call.apply(_super6, [this].concat(_toConsumableArray(children)));\n  }\n  _createClass(Or, [{\n    key: \"bind\",\n    value: function bind(batch) {\n      var bound = this.children.map(function (p) {\n        return p.bind(batch);\n      });\n      return function (idx, batch) {\n        return bound.some(function (p) {\n          return p(idx, batch);\n        });\n      };\n    }\n  }]);\n  return Or;\n}(CombinationPredicate);\n/** @ignore */\nexport var Equals = /*#__PURE__*/function (_ComparisonPredicate) {\n  _inherits(Equals, _ComparisonPredicate);\n  var _super7 = _createSuper(Equals);\n  function Equals() {\n    _classCallCheck(this, Equals);\n    return _super7.apply(this, arguments);\n  }\n  _createClass(Equals, [{\n    key: \"_bindLitLit\",\n    value: function _bindLitLit(_batch, left, right) {\n      var rtrn = left.v == right.v;\n      return function () {\n        return rtrn;\n      };\n    }\n  }, {\n    key: \"_bindColCol\",\n    value: function _bindColCol(batch, left, right) {\n      var left_func = left.bind(batch);\n      var right_func = right.bind(batch);\n      return function (idx, batch) {\n        return left_func(idx, batch) == right_func(idx, batch);\n      };\n    }\n  }, {\n    key: \"_bindColLit\",\n    value: function _bindColLit(batch, col, lit) {\n      var col_func = col.bind(batch);\n      if (col.vector instanceof DictionaryVector) {\n        var key;\n        var vector = col.vector;\n        if (vector.dictionary !== this.lastDictionary) {\n          key = vector.reverseLookup(lit.v);\n          this.lastDictionary = vector.dictionary;\n          this.lastKey = key;\n        } else {\n          key = this.lastKey;\n        }\n        if (key === -1) {\n          // the value doesn't exist in the dictionary - always return\n          // false\n          // TODO: special-case of PredicateFunc that encapsulates this\n          // \"always false\" behavior. That way filtering operations don't\n          // have to bother checking\n          return function () {\n            return false;\n          };\n        } else {\n          return function (idx) {\n            return vector.getKey(idx) === key;\n          };\n        }\n      } else {\n        return function (idx, cols) {\n          return col_func(idx, cols) == lit.v;\n        };\n      }\n    }\n  }, {\n    key: \"_bindLitCol\",\n    value: function _bindLitCol(batch, lit, col) {\n      // Equals is commutative\n      return this._bindColLit(batch, col, lit);\n    }\n  }]);\n  return Equals;\n}(ComparisonPredicate);\n/** @ignore */\nexport var LTeq = /*#__PURE__*/function (_ComparisonPredicate2) {\n  _inherits(LTeq, _ComparisonPredicate2);\n  var _super8 = _createSuper(LTeq);\n  function LTeq() {\n    _classCallCheck(this, LTeq);\n    return _super8.apply(this, arguments);\n  }\n  _createClass(LTeq, [{\n    key: \"_bindLitLit\",\n    value: function _bindLitLit(_batch, left, right) {\n      var rtrn = left.v <= right.v;\n      return function () {\n        return rtrn;\n      };\n    }\n  }, {\n    key: \"_bindColCol\",\n    value: function _bindColCol(batch, left, right) {\n      var left_func = left.bind(batch);\n      var right_func = right.bind(batch);\n      return function (idx, cols) {\n        return left_func(idx, cols) <= right_func(idx, cols);\n      };\n    }\n  }, {\n    key: \"_bindColLit\",\n    value: function _bindColLit(batch, col, lit) {\n      var col_func = col.bind(batch);\n      return function (idx, cols) {\n        return col_func(idx, cols) <= lit.v;\n      };\n    }\n  }, {\n    key: \"_bindLitCol\",\n    value: function _bindLitCol(batch, lit, col) {\n      var col_func = col.bind(batch);\n      return function (idx, cols) {\n        return lit.v <= col_func(idx, cols);\n      };\n    }\n  }]);\n  return LTeq;\n}(ComparisonPredicate);\n/** @ignore */\nexport var GTeq = /*#__PURE__*/function (_ComparisonPredicate3) {\n  _inherits(GTeq, _ComparisonPredicate3);\n  var _super9 = _createSuper(GTeq);\n  function GTeq() {\n    _classCallCheck(this, GTeq);\n    return _super9.apply(this, arguments);\n  }\n  _createClass(GTeq, [{\n    key: \"_bindLitLit\",\n    value: function _bindLitLit(_batch, left, right) {\n      var rtrn = left.v >= right.v;\n      return function () {\n        return rtrn;\n      };\n    }\n  }, {\n    key: \"_bindColCol\",\n    value: function _bindColCol(batch, left, right) {\n      var left_func = left.bind(batch);\n      var right_func = right.bind(batch);\n      return function (idx, cols) {\n        return left_func(idx, cols) >= right_func(idx, cols);\n      };\n    }\n  }, {\n    key: \"_bindColLit\",\n    value: function _bindColLit(batch, col, lit) {\n      var col_func = col.bind(batch);\n      return function (idx, cols) {\n        return col_func(idx, cols) >= lit.v;\n      };\n    }\n  }, {\n    key: \"_bindLitCol\",\n    value: function _bindLitCol(batch, lit, col) {\n      var col_func = col.bind(batch);\n      return function (idx, cols) {\n        return lit.v >= col_func(idx, cols);\n      };\n    }\n  }]);\n  return GTeq;\n}(ComparisonPredicate);\n/** @ignore */\nexport var Not = /*#__PURE__*/function (_Predicate3) {\n  _inherits(Not, _Predicate3);\n  var _super10 = _createSuper(Not);\n  function Not(child) {\n    var _this5;\n    _classCallCheck(this, Not);\n    _this5 = _super10.call(this);\n    _this5.child = child;\n    return _this5;\n  }\n  _createClass(Not, [{\n    key: \"bind\",\n    value: function bind(batch) {\n      var func = this.child.bind(batch);\n      return function (idx, batch) {\n        return !func(idx, batch);\n      };\n    }\n  }]);\n  return Not;\n}(Predicate);\n/** @ignore */\nexport var CustomPredicate = /*#__PURE__*/function (_Predicate4) {\n  _inherits(CustomPredicate, _Predicate4);\n  var _super11 = _createSuper(CustomPredicate);\n  function CustomPredicate(next, bind_) {\n    var _this6;\n    _classCallCheck(this, CustomPredicate);\n    _this6 = _super11.call(this);\n    _this6.next = next;\n    _this6.bind_ = bind_;\n    return _this6;\n  }\n  _createClass(CustomPredicate, [{\n    key: \"bind\",\n    value: function bind(batch) {\n      this.bind_(batch);\n      return this.next;\n    }\n  }]);\n  return CustomPredicate;\n}(Predicate);\nexport function lit(v) {\n  return new Literal(v);\n}\nexport function col(n) {\n  return new Col(n);\n}\nexport function and() {\n  for (var _len6 = arguments.length, p = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    p[_key6] = arguments[_key6];\n  }\n  return _construct(And, p);\n}\nexport function or() {\n  for (var _len7 = arguments.length, p = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    p[_key7] = arguments[_key7];\n  }\n  return _construct(Or, p);\n}\nexport function custom(next, bind) {\n  return new CustomPredicate(next, bind);\n}","map":{"version":3,"names":["DictionaryVector","Value","_classCallCheck","_createClass","key","value","eq","other","Literal","Equals","le","LTeq","ge","GTeq","lt","Not","gt","ne","_Value","_inherits","_super","_createSuper","v","_this","call","Col","_Value2","_super2","name","_this2","bind","batch","colidx","fields","schema","idx","length","Error","concat","vec","vector","getChildAt","get","Predicate","and","_len","arguments","expr","Array","_key","_construct","And","or","_len2","_key2","Or","not","ComparisonPredicate","_Predicate","_super3","left","right","_this3","_bindLitLit","_bindLitCol","_bindColLit","_bindColCol","CombinationPredicate","_Predicate2","_super4","_this4","_len3","children","_key3","prototype","Object","freeze","_CombinationPredicate","_super5","_len4","_key4","reduce","accum","p","apply","_toConsumableArray","bound","map","every","_CombinationPredicate2","_super6","_len5","_key5","some","_ComparisonPredicate","_super7","_batch","rtrn","left_func","right_func","col","lit","col_func","dictionary","lastDictionary","reverseLookup","lastKey","getKey","cols","_ComparisonPredicate2","_super8","_ComparisonPredicate3","_super9","_Predicate3","_super10","child","_this5","func","CustomPredicate","_Predicate4","_super11","next","bind_","_this6","n","_len6","_key6","_len7","_key7","custom"],"sources":["compute/predicate.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from '../vector';\nimport { RecordBatch } from '../recordbatch';\nimport { DictionaryVector } from '../vector/dictionary';\n\n/** @ignore */\nexport type ValueFunc<T> = (idx: number, cols: RecordBatch) => T | null;\n/** @ignore */\nexport type PredicateFunc = (idx: number, cols: RecordBatch) => boolean;\n\n/** @ignore */\nexport abstract class Value<T> {\n    eq(other: Value<T> | T): Predicate {\n        if (!(other instanceof Value)) { other = new Literal(other); }\n        return new Equals(this, other);\n    }\n    le(other: Value<T> | T): Predicate {\n        if (!(other instanceof Value)) { other = new Literal(other); }\n        return new LTeq(this, other);\n    }\n    ge(other: Value<T> | T): Predicate {\n        if (!(other instanceof Value)) { other = new Literal(other); }\n        return new GTeq(this, other);\n    }\n    lt(other: Value<T> | T): Predicate {\n        return new Not(this.ge(other));\n    }\n    gt(other: Value<T> | T): Predicate {\n        return new Not(this.le(other));\n    }\n    ne(other: Value<T> | T): Predicate {\n        return new Not(this.eq(other));\n    }\n}\n\n/** @ignore */\nexport class Literal<T= any> extends Value<T> {\n    constructor(public v: T) { super(); }\n}\n\n/** @ignore */\nexport class Col<T= any> extends Value<T> {\n    // @ts-ignore\n    public vector: Vector;\n    // @ts-ignore\n    public colidx: number;\n\n    constructor(public name: string) { super(); }\n    bind(batch: RecordBatch): (idx: number, batch?: RecordBatch) => any {\n        if (!this.colidx) {\n            // Assume column index doesn't change between calls to bind\n            //this.colidx = cols.findIndex(v => v.name.indexOf(this.name) != -1);\n            this.colidx = -1;\n            const fields = batch.schema.fields;\n            for (let idx = -1; ++idx < fields.length;) {\n                if (fields[idx].name === this.name) {\n                    this.colidx = idx;\n                    break;\n                }\n            }\n            if (this.colidx < 0) { throw new Error(`Failed to bind Col \"${this.name}\"`); }\n        }\n\n        const vec = this.vector = batch.getChildAt(this.colidx)!;\n        return (idx: number) => vec.get(idx);\n    }\n}\n\n/** @ignore */\nexport abstract class Predicate {\n    abstract bind(batch: RecordBatch): PredicateFunc;\n    and(...expr: Predicate[]): And { return new And(this, ...expr); }\n    or(...expr: Predicate[]): Or { return new Or(this, ...expr); }\n    not(): Predicate { return new Not(this); }\n}\n\n/** @ignore */\nexport abstract class ComparisonPredicate<T= any> extends Predicate {\n    constructor(public readonly left: Value<T>, public readonly right: Value<T>) {\n        super();\n    }\n\n    bind(batch: RecordBatch) {\n        if (this.left instanceof Literal) {\n            if (this.right instanceof Literal) {\n                return this._bindLitLit(batch, this.left, this.right);\n            } else { // right is a Col\n\n                return this._bindLitCol(batch, this.left, this.right as Col);\n            }\n        } else { // left is a Col\n            if (this.right instanceof Literal) {\n                return this._bindColLit(batch, this.left as Col, this.right);\n            } else { // right is a Col\n                return this._bindColCol(batch, this.left as Col, this.right as Col);\n            }\n        }\n    }\n\n    protected abstract _bindLitLit(batch: RecordBatch, left: Literal, right: Literal): PredicateFunc;\n    protected abstract _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc;\n    protected abstract _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc;\n    protected abstract _bindLitCol(batch: RecordBatch, lit: Literal, col: Col): PredicateFunc;\n}\n\n/** @ignore */\nexport abstract class CombinationPredicate extends Predicate {\n    readonly children: Predicate[];\n    constructor(...children: Predicate[]) {\n        super();\n        this.children = children;\n    }\n}\n// add children to prototype so it doesn't get mangled in es2015/umd\n(<any> CombinationPredicate.prototype).children = Object.freeze([]); // freeze for safety\n\n/** @ignore */\nexport class And extends CombinationPredicate {\n    constructor(...children: Predicate[]) {\n        // Flatten any Ands\n        children = children.reduce((accum: Predicate[], p: Predicate): Predicate[] => {\n            return accum.concat(p instanceof And ? p.children : p);\n        }, []);\n        super(...children);\n    }\n    bind(batch: RecordBatch) {\n        const bound = this.children.map((p) => p.bind(batch));\n        return (idx: number, batch: RecordBatch) => bound.every((p) => p(idx, batch));\n    }\n}\n\n/** @ignore */\nexport class Or extends CombinationPredicate {\n    constructor(...children: Predicate[]) {\n        // Flatten any Ors\n        children = children.reduce((accum: Predicate[], p: Predicate): Predicate[] => {\n            return accum.concat(p instanceof Or ? p.children : p);\n        }, []);\n        super(...children);\n    }\n    bind(batch: RecordBatch) {\n        const bound = this.children.map((p) => p.bind(batch));\n        return (idx: number, batch: RecordBatch) => bound.some((p) => p(idx, batch));\n    }\n}\n\n/** @ignore */\nexport class Equals extends ComparisonPredicate {\n    // Helpers used to cache dictionary reverse lookups between calls to bind\n    private lastDictionary: Vector|undefined;\n    private lastKey: number|undefined;\n\n    protected _bindLitLit(_batch: RecordBatch, left: Literal, right: Literal): PredicateFunc {\n        const rtrn: boolean = left.v == right.v;\n        return () => rtrn;\n    }\n\n    protected _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc {\n        const left_func = left.bind(batch);\n        const right_func = right.bind(batch);\n        return (idx: number, batch: RecordBatch) => left_func(idx, batch) == right_func(idx, batch);\n    }\n\n    protected _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc {\n        const col_func = col.bind(batch);\n        if (col.vector instanceof DictionaryVector) {\n            let key: any;\n            const vector = col.vector as DictionaryVector;\n            if (vector.dictionary !== this.lastDictionary) {\n                key = vector.reverseLookup(lit.v);\n                this.lastDictionary = vector.dictionary;\n                this.lastKey = key;\n            } else {\n                key = this.lastKey;\n            }\n\n            if (key === -1) {\n                // the value doesn't exist in the dictionary - always return\n                // false\n                // TODO: special-case of PredicateFunc that encapsulates this\n                // \"always false\" behavior. That way filtering operations don't\n                // have to bother checking\n                return () => false;\n            } else {\n                return (idx: number) => {\n                    return vector.getKey(idx) === key;\n                };\n            }\n        } else {\n            return (idx: number, cols: RecordBatch) => col_func(idx, cols) == lit.v;\n        }\n    }\n\n    protected _bindLitCol(batch: RecordBatch, lit: Literal, col: Col) {\n        // Equals is commutative\n        return this._bindColLit(batch, col, lit);\n    }\n}\n\n/** @ignore */\nexport class LTeq extends ComparisonPredicate {\n    protected _bindLitLit(_batch: RecordBatch, left: Literal, right: Literal): PredicateFunc {\n        const rtrn: boolean = left.v <= right.v;\n        return () => rtrn;\n    }\n\n    protected _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc {\n        const left_func = left.bind(batch);\n        const right_func = right.bind(batch);\n        return (idx: number, cols: RecordBatch) => left_func(idx, cols) <= right_func(idx, cols);\n    }\n\n    protected _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => col_func(idx, cols) <= lit.v;\n    }\n\n    protected _bindLitCol(batch: RecordBatch, lit: Literal, col: Col) {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => lit.v <= col_func(idx, cols);\n    }\n}\n\n/** @ignore */\nexport class GTeq extends ComparisonPredicate {\n    protected _bindLitLit(_batch: RecordBatch, left: Literal, right: Literal): PredicateFunc {\n        const rtrn: boolean = left.v >= right.v;\n        return () => rtrn;\n    }\n\n    protected _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc {\n        const left_func = left.bind(batch);\n        const right_func = right.bind(batch);\n        return (idx: number, cols: RecordBatch) => left_func(idx, cols) >= right_func(idx, cols);\n    }\n\n    protected _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => col_func(idx, cols) >= lit.v;\n    }\n\n    protected _bindLitCol(batch: RecordBatch, lit: Literal, col: Col) {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => lit.v >= col_func(idx, cols);\n    }\n}\n\n/** @ignore */\nexport class Not extends Predicate {\n    constructor(public readonly child: Predicate) {\n        super();\n    }\n\n    bind(batch: RecordBatch) {\n        const func = this.child.bind(batch);\n        return (idx: number, batch: RecordBatch) => !func(idx, batch);\n    }\n}\n\n/** @ignore */\nexport class CustomPredicate extends Predicate {\n    constructor(private next: PredicateFunc, private bind_: (batch: RecordBatch) => void) {\n        super();\n    }\n\n    bind(batch: RecordBatch) {\n        this.bind_(batch);\n        return this.next;\n    }\n}\n\nexport function lit(v: any): Value<any> { return new Literal(v); }\nexport function col(n: string): Col<any> { return new Col(n); }\nexport function and(...p: Predicate[]): And { return new And(...p); }\nexport function or(...p: Predicate[]): Or { return new Or(...p); }\nexport function custom(next: PredicateFunc, bind: (batch: RecordBatch) => void) {\n    return new CustomPredicate(next, bind);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}