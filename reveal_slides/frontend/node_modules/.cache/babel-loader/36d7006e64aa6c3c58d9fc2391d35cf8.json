{"ast":null,"code":"import _classCallCheck from \"/home/anasbouzid/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/anasbouzid/streamlit-reveal-slides/reveal_slides/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { truncateBitmap } from './util/bit';\nimport { popcnt_bit_range } from './util/bit';\nimport { BufferType, UnionMode, Type } from './enum';\nimport { strideForType } from './type';\nimport { toArrayBufferView, toUint8Array, toInt32Array } from './util/buffer';\n/** @ignore */\nexport var kUnknownNullCount = -1;\n/** @ignore */\nexport var Data = /*#__PURE__*/function () {\n  function Data(type, offset, length, nullCount, buffers, childData, dictionary) {\n    _classCallCheck(this, Data);\n    this.type = type;\n    this.dictionary = dictionary;\n    this.offset = Math.floor(Math.max(offset || 0, 0));\n    this.length = Math.floor(Math.max(length || 0, 0));\n    this._nullCount = Math.floor(Math.max(nullCount || 0, -1));\n    this.childData = (childData || []).map(function (x) {\n      return x instanceof Data ? x : x.data;\n    });\n    var buffer;\n    if (buffers instanceof Data) {\n      this.stride = buffers.stride;\n      this.values = buffers.values;\n      this.typeIds = buffers.typeIds;\n      this.nullBitmap = buffers.nullBitmap;\n      this.valueOffsets = buffers.valueOffsets;\n    } else {\n      this.stride = strideForType(type);\n      if (buffers) {\n        (buffer = buffers[0]) && (this.valueOffsets = buffer);\n        (buffer = buffers[1]) && (this.values = buffer);\n        (buffer = buffers[2]) && (this.nullBitmap = buffer);\n        (buffer = buffers[3]) && (this.typeIds = buffer);\n      }\n    }\n  }\n  _createClass(Data, [{\n    key: \"typeId\",\n    get: function get() {\n      return this.type.typeId;\n    }\n  }, {\n    key: \"ArrayType\",\n    get: function get() {\n      return this.type.ArrayType;\n    }\n  }, {\n    key: \"buffers\",\n    get: function get() {\n      return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];\n    }\n  }, {\n    key: \"byteLength\",\n    get: function get() {\n      var byteLength = 0;\n      var valueOffsets = this.valueOffsets,\n        values = this.values,\n        nullBitmap = this.nullBitmap,\n        typeIds = this.typeIds;\n      valueOffsets && (byteLength += valueOffsets.byteLength);\n      values && (byteLength += values.byteLength);\n      nullBitmap && (byteLength += nullBitmap.byteLength);\n      typeIds && (byteLength += typeIds.byteLength);\n      return this.childData.reduce(function (byteLength, child) {\n        return byteLength + child.byteLength;\n      }, byteLength);\n    }\n  }, {\n    key: \"nullCount\",\n    get: function get() {\n      var nullCount = this._nullCount;\n      var nullBitmap;\n      if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {\n        this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);\n      }\n      return nullCount;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(type) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.offset;\n      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.length;\n      var nullCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._nullCount;\n      var buffers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this;\n      var childData = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.childData;\n      return new Data(type, offset, length, nullCount, buffers, childData, this.dictionary);\n    }\n  }, {\n    key: \"slice\",\n    value: function slice(offset, length) {\n      var stride = this.stride,\n        typeId = this.typeId,\n        childData = this.childData;\n      // +true === 1, +false === 0, so this means\n      // we keep nullCount at 0 if it's already 0,\n      // otherwise set to the invalidated flag -1\n      var nullCount = +(this._nullCount === 0) - 1;\n      var childStride = typeId === 16 /* FixedSizeList */ ? stride : 1;\n      var buffers = this._sliceBuffers(offset, length, stride, typeId);\n      return this.clone(this.type, this.offset + offset, length, nullCount, buffers,\n      // Don't slice children if we have value offsets (the variable-width types)\n      !childData.length || this.valueOffsets ? childData : this._sliceChildren(childData, childStride * offset, childStride * length));\n    }\n  }, {\n    key: \"_changeLengthAndBackfillNullBitmap\",\n    value: function _changeLengthAndBackfillNullBitmap(newLength) {\n      if (this.typeId === Type.Null) {\n        return this.clone(this.type, 0, newLength, 0);\n      }\n      var length = this.length,\n        nullCount = this.nullCount;\n      // start initialized with 0s (nulls), then fill from 0 to length with 1s (not null)\n      var bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length >> 3);\n      // set all the bits in the last byte (up to bit `length - length % 8`) to 1 (not null)\n      bitmap[length >> 3] = (1 << length - (length & ~7)) - 1;\n      // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s\n      if (nullCount > 0) {\n        bitmap.set(truncateBitmap(this.offset, length, this.nullBitmap), 0);\n      }\n      var buffers = this.buffers;\n      buffers[BufferType.VALIDITY] = bitmap;\n      return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);\n    }\n  }, {\n    key: \"_sliceBuffers\",\n    value: function _sliceBuffers(offset, length, stride, typeId) {\n      var arr,\n        buffers = this.buffers;\n      // If typeIds exist, slice the typeIds buffer\n      (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset, offset + length));\n      // If offsets exist, only slice the offsets buffer\n      (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) ||\n      // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes\n      (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));\n      return buffers;\n    }\n  }, {\n    key: \"_sliceChildren\",\n    value: function _sliceChildren(childData, offset, length) {\n      return childData.map(function (child) {\n        return child.slice(offset, length);\n      });\n    }\n    //\n    // Convenience methods for creating Data instances for each of the Arrow Vector types\n    //\n    /** @nocollapse */\n  }], [{\n    key: \"new\",\n    value: function _new(type, offset, length, nullCount, buffers, childData, dictionary) {\n      if (buffers instanceof Data) {\n        buffers = buffers.buffers;\n      } else if (!buffers) {\n        buffers = [];\n      }\n      switch (type.typeId) {\n        case Type.Null:\n          return Data.Null(type, offset, length);\n        case Type.Int:\n          return Data.Int(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n        case Type.Dictionary:\n          return Data.Dictionary(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || [], dictionary);\n        case Type.Float:\n          return Data.Float(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n        case Type.Bool:\n          return Data.Bool(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n        case Type.Decimal:\n          return Data.Decimal(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n        case Type.Date:\n          return Data.Date(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n        case Type.Time:\n          return Data.Time(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n        case Type.Timestamp:\n          return Data.Timestamp(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n        case Type.Interval:\n          return Data.Interval(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n        case Type.FixedSizeBinary:\n          return Data.FixedSizeBinary(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n        case Type.Binary:\n          return Data.Binary(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], buffers[BufferType.DATA] || []);\n        case Type.Utf8:\n          return Data.Utf8(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], buffers[BufferType.DATA] || []);\n        case Type.List:\n          return Data.List(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], (childData || [])[0]);\n        case Type.FixedSizeList:\n          return Data.FixedSizeList(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], (childData || [])[0]);\n        case Type.Struct:\n          return Data.Struct(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], childData || []);\n        case Type.Map:\n          return Data.Map(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], (childData || [])[0]);\n        case Type.Union:\n          return Data.Union(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.TYPE] || [], buffers[BufferType.OFFSET] || childData, childData);\n      }\n      throw new Error(\"Unrecognized typeId \".concat(type.typeId));\n    }\n    /** @nocollapse */\n  }, {\n    key: \"Null\",\n    value: function Null(type, offset, length) {\n      return new Data(type, offset, length, 0);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"Int\",\n    value: function Int(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"Dictionary\",\n    value: function Dictionary(type, offset, length, nullCount, nullBitmap, data, dictionary) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.indices.ArrayType, data), toUint8Array(nullBitmap)], [], dictionary);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"Float\",\n    value: function Float(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"Bool\",\n    value: function Bool(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"Decimal\",\n    value: function Decimal(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"Date\",\n    value: function Date(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"Time\",\n    value: function Time(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"Timestamp\",\n    value: function Timestamp(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"Interval\",\n    value: function Interval(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"FixedSizeBinary\",\n    value: function FixedSizeBinary(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"Binary\",\n    value: function Binary(type, offset, length, nullCount, nullBitmap, valueOffsets, data) {\n      return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), toUint8Array(data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"Utf8\",\n    value: function Utf8(type, offset, length, nullCount, nullBitmap, valueOffsets, data) {\n      return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), toUint8Array(data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"List\",\n    value: function List(type, offset, length, nullCount, nullBitmap, valueOffsets, child) {\n      return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"FixedSizeList\",\n    value: function FixedSizeList(type, offset, length, nullCount, nullBitmap, child) {\n      return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"Struct\",\n    value: function Struct(type, offset, length, nullCount, nullBitmap, children) {\n      return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)], children);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"Map\",\n    value: function Map(type, offset, length, nullCount, nullBitmap, valueOffsets, child) {\n      return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    /** @nocollapse */\n  }, {\n    key: \"Union\",\n    value: function Union(type, offset, length, nullCount, nullBitmap, typeIds, valueOffsetsOrChildren, children) {\n      var buffers = [undefined, undefined, toUint8Array(nullBitmap), toArrayBufferView(type.ArrayType, typeIds)];\n      if (type.mode === UnionMode.Sparse) {\n        return new Data(type, offset, length, nullCount, buffers, valueOffsetsOrChildren);\n      }\n      buffers[BufferType.OFFSET] = toInt32Array(valueOffsetsOrChildren);\n      return new Data(type, offset, length, nullCount, buffers, children);\n    }\n  }]);\n  return Data;\n}();\nData.prototype.childData = Object.freeze([]);","map":{"version":3,"names":["truncateBitmap","popcnt_bit_range","BufferType","UnionMode","Type","strideForType","toArrayBufferView","toUint8Array","toInt32Array","kUnknownNullCount","Data","type","offset","length","nullCount","buffers","childData","dictionary","_classCallCheck","Math","floor","max","_nullCount","map","x","data","buffer","stride","values","typeIds","nullBitmap","valueOffsets","_createClass","key","get","typeId","ArrayType","byteLength","reduce","child","value","clone","arguments","undefined","slice","childStride","_sliceBuffers","_sliceChildren","_changeLengthAndBackfillNullBitmap","newLength","Null","bitmap","Uint8Array","fill","set","VALIDITY","arr","TYPE","subarray","OFFSET","DATA","_new","Int","Dictionary","Float","Bool","Decimal","Date","Time","Timestamp","Interval","FixedSizeBinary","Binary","Utf8","List","FixedSizeList","Struct","Map","Union","Error","concat","indices","children","valueOffsetsOrChildren","mode","Sparse","prototype","Object","freeze"],"sources":["data.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from './vector';\nimport { truncateBitmap } from './util/bit';\nimport { popcnt_bit_range } from './util/bit';\nimport { BufferType, UnionMode, Type } from './enum';\nimport { DataType, SparseUnion, DenseUnion, strideForType } from './type';\nimport { toArrayBufferView, toUint8Array, toInt32Array } from './util/buffer';\nimport {\n    Dictionary,\n    Null, Int, Float,\n    Binary, Bool, Utf8, Decimal,\n    Date_, Time, Timestamp, Interval,\n    List, Struct, Union, FixedSizeBinary, FixedSizeList, Map_,\n} from './type';\n\n// When slicing, we do not know the null count of the sliced range without\n// doing some computation. To avoid doing this eagerly, we set the null count\n// to -1 (any negative number will do). When Vector.nullCount is called the\n// first time, the null count will be computed. See ARROW-33\n/** @ignore */ export type kUnknownNullCount = -1;\n/** @ignore */ export const kUnknownNullCount = -1;\n\n/** @ignore */ export type NullBuffer = Uint8Array | null | undefined;\n/** @ignore */ export type TypeIdsBuffer = Int8Array  | ArrayLike<number> | Iterable<number> | undefined;\n/** @ignore */ export type ValueOffsetsBuffer = Int32Array  | ArrayLike<number> | Iterable<number> | undefined;\n/** @ignore */ export type DataBuffer<T extends DataType> = T['TArray'] | ArrayLike<number> | Iterable<number> | undefined;\n\n/** @ignore */\nexport interface Buffers<T extends DataType> {\n      [BufferType.OFFSET]: Int32Array;\n        [BufferType.DATA]: T['TArray'];\n    [BufferType.VALIDITY]: Uint8Array;\n        [BufferType.TYPE]: T['TArray'];\n}\n\n/** @ignore */\nexport interface Data<T extends DataType = DataType> {\n    readonly TType: T['TType'];\n    readonly TArray: T['TArray'];\n    readonly TValue: T['TValue'];\n}\n\n/** @ignore */\nexport class Data<T extends DataType = DataType> {\n\n    public readonly type: T;\n    public readonly length: number;\n    public readonly offset: number;\n    public readonly stride: number;\n    public readonly childData: Data[];\n\n    /**\n     * The dictionary for this Vector, if any. Only used for Dictionary type.\n     */\n    public dictionary?: Vector;\n\n    public readonly values: Buffers<T>[BufferType.DATA];\n    // @ts-ignore\n    public readonly typeIds: Buffers<T>[BufferType.TYPE];\n    // @ts-ignore\n    public readonly nullBitmap: Buffers<T>[BufferType.VALIDITY];\n    // @ts-ignore\n    public readonly valueOffsets: Buffers<T>[BufferType.OFFSET];\n\n    public get typeId(): T['TType'] { return this.type.typeId; }\n    public get ArrayType(): T['ArrayType'] { return this.type.ArrayType; }\n    public get buffers() {\n        return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds] as Buffers<T>;\n    }\n    public get byteLength(): number {\n        let byteLength = 0;\n        let { valueOffsets, values, nullBitmap, typeIds } = this;\n        valueOffsets && (byteLength += valueOffsets.byteLength);\n        values       && (byteLength += values.byteLength);\n        nullBitmap   && (byteLength += nullBitmap.byteLength);\n        typeIds      && (byteLength += typeIds.byteLength);\n        return this.childData.reduce((byteLength, child) => byteLength + child.byteLength, byteLength);\n    }\n\n    protected _nullCount: number | kUnknownNullCount;\n\n    public get nullCount() {\n        let nullCount = this._nullCount;\n        let nullBitmap: Uint8Array | undefined;\n        if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {\n            this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);\n        }\n        return nullCount;\n    }\n\n    constructor(type: T, offset: number, length: number, nullCount?: number, buffers?: Partial<Buffers<T>> | Data<T>, childData?: (Data | Vector)[], dictionary?: Vector) {\n        this.type = type;\n        this.dictionary = dictionary;\n        this.offset = Math.floor(Math.max(offset || 0, 0));\n        this.length = Math.floor(Math.max(length || 0, 0));\n        this._nullCount = Math.floor(Math.max(nullCount || 0, -1));\n        this.childData = (childData || []).map((x) => x instanceof Data ? x : x.data) as Data[];\n        let buffer: Buffers<T>[keyof Buffers<T>];\n        if (buffers instanceof Data) {\n            this.stride = buffers.stride;\n            this.values = buffers.values;\n            this.typeIds = buffers.typeIds;\n            this.nullBitmap = buffers.nullBitmap;\n            this.valueOffsets = buffers.valueOffsets;\n        } else {\n            this.stride = strideForType(type);\n            if (buffers) {\n                (buffer = (buffers as Buffers<T>)[0]) && (this.valueOffsets = buffer);\n                (buffer = (buffers as Buffers<T>)[1]) && (this.values = buffer);\n                (buffer = (buffers as Buffers<T>)[2]) && (this.nullBitmap = buffer);\n                (buffer = (buffers as Buffers<T>)[3]) && (this.typeIds = buffer);\n            }\n        }\n    }\n\n    public clone<R extends DataType>(type: R, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers: Buffers<R> = <any> this, childData: (Data | Vector)[] = this.childData) {\n        return new Data(type, offset, length, nullCount, buffers, childData, this.dictionary);\n    }\n\n    public slice(offset: number, length: number): Data<T> {\n        const { stride, typeId, childData } = this;\n        // +true === 1, +false === 0, so this means\n        // we keep nullCount at 0 if it's already 0,\n        // otherwise set to the invalidated flag -1\n        const nullCount = +(this._nullCount === 0) - 1;\n        const childStride = typeId === 16 /* FixedSizeList */ ? stride : 1;\n        const buffers = this._sliceBuffers(offset, length, stride, typeId);\n        return this.clone<T>(this.type, this.offset + offset, length, nullCount, buffers,\n            // Don't slice children if we have value offsets (the variable-width types)\n            (!childData.length || this.valueOffsets) ? childData : this._sliceChildren(childData, childStride * offset, childStride * length));\n    }\n\n    public _changeLengthAndBackfillNullBitmap(newLength: number): Data<T> {\n        if (this.typeId === Type.Null) {\n            return this.clone(this.type, 0, newLength, 0);\n        }\n        const { length, nullCount } = this;\n        // start initialized with 0s (nulls), then fill from 0 to length with 1s (not null)\n        const bitmap = new Uint8Array(((newLength + 63) & ~63) >> 3).fill(255, 0, length >> 3);\n        // set all the bits in the last byte (up to bit `length - length % 8`) to 1 (not null)\n        bitmap[length >> 3] = (1 << (length - (length & ~7))) - 1;\n        // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s\n        if (nullCount > 0) {\n            bitmap.set(truncateBitmap(this.offset, length, this.nullBitmap), 0);\n        }\n        const buffers = this.buffers;\n        buffers[BufferType.VALIDITY] = bitmap;\n        return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);\n    }\n\n    protected _sliceBuffers(offset: number, length: number, stride: number, typeId: T['TType']): Buffers<T> {\n        let arr: any, { buffers } = this;\n        // If typeIds exist, slice the typeIds buffer\n        (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset, offset + length));\n        // If offsets exist, only slice the offsets buffer\n        (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) ||\n        // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes\n        (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));\n        return buffers;\n    }\n\n    protected _sliceChildren(childData: Data[], offset: number, length: number): Data[] {\n        return childData.map((child) => child.slice(offset, length));\n    }\n\n    //\n    // Convenience methods for creating Data instances for each of the Arrow Vector types\n    //\n    /** @nocollapse */\n    public static new<T extends DataType>(type: T, offset: number, length: number, nullCount?: number, buffers?: Partial<Buffers<T>> | Data<T>, childData?: (Data | Vector)[], dictionary?: Vector): Data<T> {\n        if (buffers instanceof Data) { buffers = buffers.buffers; } else if (!buffers) { buffers = [] as Partial<Buffers<T>>; }\n        switch (type.typeId) {\n            case Type.Null:            return <unknown> Data.Null(            <unknown> type as Null,            offset, length) as Data<T>;\n            case Type.Int:             return <unknown> Data.Int(             <unknown> type as Int,             offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Dictionary:      return <unknown> Data.Dictionary(      <unknown> type as Dictionary,      offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || [], dictionary!) as Data<T>;\n            case Type.Float:           return <unknown> Data.Float(           <unknown> type as Float,           offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Bool:            return <unknown> Data.Bool(            <unknown> type as Bool,            offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Decimal:         return <unknown> Data.Decimal(         <unknown> type as Decimal,         offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Date:            return <unknown> Data.Date(            <unknown> type as Date_,           offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Time:            return <unknown> Data.Time(            <unknown> type as Time,            offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Timestamp:       return <unknown> Data.Timestamp(       <unknown> type as Timestamp,       offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Interval:        return <unknown> Data.Interval(        <unknown> type as Interval,        offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.FixedSizeBinary: return <unknown> Data.FixedSizeBinary( <unknown> type as FixedSizeBinary, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Binary:          return <unknown> Data.Binary(          <unknown> type as Binary,          offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Utf8:            return <unknown> Data.Utf8(            <unknown> type as Utf8,            offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.List:            return <unknown> Data.List(            <unknown> type as List,            offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], (childData || [])[0]) as Data<T>;\n            case Type.FixedSizeList:   return <unknown> Data.FixedSizeList(   <unknown> type as FixedSizeList,   offset, length, nullCount || 0, buffers[BufferType.VALIDITY], (childData || [])[0]) as Data<T>;\n            case Type.Struct:          return <unknown> Data.Struct(          <unknown> type as Struct,          offset, length, nullCount || 0, buffers[BufferType.VALIDITY], childData || []) as Data<T>;\n            case Type.Map:             return <unknown> Data.Map(             <unknown> type as Map_,            offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], (childData || [])[0]) as Data<T>;\n            case Type.Union:           return <unknown> Data.Union(           <unknown> type as Union,           offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.TYPE] || [], buffers[BufferType.OFFSET] || childData, childData) as Data<T>;\n        }\n        throw new Error(`Unrecognized typeId ${type.typeId}`);\n    }\n\n    /** @nocollapse */\n    public static Null<T extends Null>(type: T, offset: number, length: number) {\n        return new Data(type, offset, length, 0);\n    }\n    /** @nocollapse */\n    public static Int<T extends Int>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Dictionary<T extends Dictionary>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>, dictionary: Vector<T['dictionary']>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView<T['TArray']>(type.indices.ArrayType, data), toUint8Array(nullBitmap)], [], dictionary);\n    }\n    /** @nocollapse */\n    public static Float<T extends Float>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Bool<T extends Bool>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Decimal<T extends Decimal>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Date<T extends Date_>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Time<T extends Time>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Timestamp<T extends Timestamp>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Interval<T extends Interval>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static FixedSizeBinary<T extends FixedSizeBinary>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Binary<T extends Binary>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, valueOffsets: ValueOffsetsBuffer, data: Uint8Array) {\n        return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), toUint8Array(data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Utf8<T extends Utf8>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, valueOffsets: ValueOffsetsBuffer, data: Uint8Array) {\n        return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), toUint8Array(data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static List<T extends List>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, valueOffsets: ValueOffsetsBuffer, child: Data<T['valueType']> | Vector<T['valueType']>) {\n        return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    /** @nocollapse */\n    public static FixedSizeList<T extends FixedSizeList>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, child: Data<T['valueType']> | Vector<T['valueType']>) {\n        return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    /** @nocollapse */\n    public static Struct<T extends Struct>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, children: (Data | Vector)[]) {\n        return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)], children);\n    }\n    /** @nocollapse */\n    public static Map<T extends Map_>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, valueOffsets: ValueOffsetsBuffer, child: (Data | Vector)) {\n        return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    public static Union<T extends SparseUnion>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, typeIds: TypeIdsBuffer, children: (Data | Vector)[], _?: any): Data<T>;\n    public static Union<T extends DenseUnion>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, typeIds: TypeIdsBuffer, valueOffsets: ValueOffsetsBuffer, children: (Data | Vector)[]): Data<T>;\n    public static Union<T extends Union>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, typeIds: TypeIdsBuffer, valueOffsetsOrChildren: ValueOffsetsBuffer | (Data | Vector)[], children?: (Data | Vector)[]): Data<T>;\n    /** @nocollapse */\n    public static Union<T extends Union>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, typeIds: TypeIdsBuffer, valueOffsetsOrChildren: ValueOffsetsBuffer | (Data | Vector)[], children?: (Data | Vector)[]) {\n        const buffers = <unknown> [\n            undefined, undefined,\n            toUint8Array(nullBitmap),\n            toArrayBufferView(type.ArrayType, typeIds)\n        ] as Partial<Buffers<T>>;\n        if (type.mode === UnionMode.Sparse) {\n            return new Data(type, offset, length, nullCount, buffers, valueOffsetsOrChildren as (Data | Vector)[]);\n        }\n        buffers[BufferType.OFFSET] = toInt32Array(<ValueOffsetsBuffer> valueOffsetsOrChildren);\n        return new Data(type, offset, length, nullCount, buffers, children);\n    }\n}\n\n(Data.prototype as any).childData = Object.freeze([]);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}